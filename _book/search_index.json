[
["index.html", "Guia definitivo do R para estudantes de sociais Prefácio Motivação Organização Sobre o autor Agradecimentos", " Guia definitivo do R para estudantes de sociais Prefácio Colocar aqui o que me feze escrever o livro motivações e inspirações. Lembrar que foi dia 17/09/2017 que eu vi o vídeo que me inspirei. Motivação De maneira sucinta este livro é minha humilde tentativa de facilitar o aprendizado e utilização da linguagem R para alunos de graduação em ciências sociais, inevitavelmente, em especial economia. descrever o problema de que ao fazer trabalhos relacionados a dados (isto pe usar o excel pra guardar dados, algum software para fazer a análise copiar e colar para o word e depois se alguma coisa mudar tem que fazer toda a análise novamente) Para quem é este livro? Alunos de graduação que usam estatística para fazer trabalhos, em especial (mas não exclusivamente) para os do campo de ciências sociais. falar que esse livro é feito sob a premissa de facilitar a implementação/execução de trabalhos relacionados a análise de dados. falar que eu não pretendo ensinar a parte teórica é um livro de aplicação! Então é uma base de estatística/econometria ajuda muito a entender o livro O que você vai aprender neste livro Aprender o funcionamento do R no RStudio como linguagem de programação estatística. O que são o R e o RStudio (colocar aqui que não vou ensinar a instalar os programas pois há muito material sobre isso na internet) Mostrar os processos tradicionais de trabalhos relacionados a analise dados e mostrar como o R facilita o processo de analise dados em cada um dos processos tradicionais mostrar como juntar todas esses processos podem ser todos executados no mesmo local. que em atividades simples pode ser mais demorado fazer coisas no r, mas que com o aumento da complexidade da tarefa o r fica muito mais rapido de se fazer Organização Esta parte mostra como o livro e os capítulos estão organizados Convenções do livro descrever aqui os padrões utilizados no livro, por enquanto são: Nos chunks: &gt; indicam o código que foi executado e # resultado (output) do código executado. No texto: palavras em outros idiomas estarão em itálico, coisas que estiverem relacionamdas ao R (funções, variaveis, comandos etc) estão destacados como codigo. Os exemplos do livro trarão em si todo o código necessário para que o leitor possa reproduzi-los, salvo dito explicitamente o contrário. Vai ser comum, especialmente no começo, o leitor não entender por completo os códigos dos exemplos, mas o importante é que o leitor compreenda as partes do código referentes especificamente ao exemplo. Faço isso por dois motivos:(i) para que o leitor vá se acostumando aos poucos sem perceber com a sintaxe do R; e (ii) uma das coisas que me incomodou ao aprender é que é comum que sejam apresentados apenas pedaços de código e isso dificulta o entendimento de o que está sendo feito no geral.Será comentado todo o código apresentado para que o leitor entenda o que está sendo feito, mas com o foco sempre na parte referente ao exemplo. Pois, acredito que entendendo a “figura como um todo” é mais natutal compreender os detalhes Organização do livro Descrever aqui a lógica da organização do livro e um resumo de o que cada capítulo ensina. falar que a primeira parte busca apresentar as peças fundamentais para as outras partes, e por isso talvez seja um pouco mais chata. mas não desiste toda bonita residência começa com tijolos iguais. Organização dos capítulos Cada capítulo apresenta aspectos expositivos sobre determinado tema, além disso no final de cada capítulo há uma seção com exercícios práticos com o intuito de reinterar o que foi mostrado na parte expositiva e acrescentar coisas que não foram mostradas explicitamente na parte expositiva. Também são apresentados exemplos práticos (que podem ser reproduzidos pelo leitor) ao longo da parte expositiva. Sobre o autor Agradecimentos "],
["r-e-rStudio.html", "1 R e RStudio 1.1 O que são 1.2 Layout do RStudio 1.3 Scripts 1.4 Funcionamento do Código 1.5 Working Directory (ou pasta de trabalho) 1.6 Pacotes (ou libraries)", " 1 R e RStudio Neste capítulo vamos introduzir de maneira completa o R e o RStudio e apresentar o básico sobre seu funcionamento. De modo a facilitar o entendimento dos capítulos seguintes desta parte I do livro, que busca apresentar ferramentas sob as quais desenvolveremos nossas habilidades no R. 1.1 O que são R é uma linguagem de programação estatística baseada em comandos de linha, de modo que é dado ao usuário uma liberdade e flexilibidade na hora de fazer as análises. O RStudio é um ambiente de programação que torna mais fácil e eficiente a utilização do R. Matloff (2011) apresenta a analogia de Greg Snow para exemplificar a lógica do R. Podemos pensar no mundo de análise dados como sendo uma cidade e as possíveis análises são diferentes locais nesta nossa cidade hipotética. Os principais meios de locomoção que pensamos são transporte público (ônibus, metrô, bondinho etc.) e transporte privado (em especial carros). Analisando as possilidades sabemos que andar de ônibus é mais fácil, basta pagar a passagem saber em qual ponto subir e em qual ponto descer. Já para poder utilizar o carro há um custo de aprender a dirigir o carro, ter um conhecimento de leis, e significados de placas, ter uma espécie de mapa mental para saber onde está indo (além do financeiro hehe) e etc. Mas e afinal de contas qual é a vantagem de se utilizar o transporte privado no lugar do público? É o simples fato de ser mais confortável e possibilitar você conseguir chegar em locais que o transporte público não te levaria sem uma boa caminhada. Destaco que a analogia foi feita antes de surgir aplicativos como UBER, e na minha interpretação andar de UBER seria como pagar alguém para fazer a análise por você. O ponto é que utilizar pacotes estatíscos de botões (como SPSS, Gretl, Stata e afins) é como se você estivesse utilizando o transporte público, ao passo que ao introduzir ferramentas de programação (como o R e Python fazem, por exemplo) abre inúmeras possibilidades que são limitadas apenas pelo conhecimento do usuário. Deste modo você consegue chegar em lugares novos e chegar mais rápido em lugares que de outra maneira seria mais demorado. Dito isso, o primeiro passo para entrarmos no mundo é baixar e instalar p O eo RStudio. Para baixar o R acesse o site do R Project (https://www.r-project.org/), clique em download R e em seguida escolha um dos mirrors brasileiros, a figura 1.1 sintetizaos passos. O próximo passo é apenas executar o arquivo baixado. Figure 1.1: Baixando o R Figure 1.1: Baixando o R Já o RStudio, como dito anteriormente, é um ambiente que torna a utilização da linguagem R mais agradavél e possibilita uma organização muito boa da análise que está sendo feita. Para baixar o RStudio acesse o site do RStudio (https://www.rstudio.com/), clique no icone Download RSstudio, em seguida clique em Desktop Open Source License e por fim basta executar o arquivo baixado, a figura 1.2 sintetiza os passos. Figure 1.2: Baixando o RStudio Figure 1.2: Baixando o RStudio É importante destacar que a ordem de instalação deve ser respeitada,isto é, primeiro instalr o R e depois o RStudio. 1.2 Layout do RStudio Depois de instalar o R e RStudio abra o RStudio, pois como comentado anteriorment o RStudio é um ambiente que torna mais eficiente a programação em R, e desse modo utilizaremos ele como interface para usar o R. Ao abrir o RStudio você deve se deparar com o layout apresentado na figura 1.3. Figure 1.3: Layout do RStudio Esse layout apresenta 4 janelas principais para se usar o R no RStudio. De maneira sucinta: A janela superior esquerda é o script que, como veremos em seguida, é onde o código é escrito para ser executado; A janela superior direita, chamada de environment, e é onde encontram-se as variáveis, dados, e objetos; A janela inferior esquerda é o console onde são exibidos os resultados que não são figuras, como tabelas, regressões, contas etc; E por fim, a janela do canto inferior direito é onde são exibidos os plots produzidos. 1.3 Scripts Outra grande vantagem de se utilizar linguagens baseadas em comandos de linha são os scripts que são onde ficam armazenados os comandos que devem ser executados, no caso do R os scripts são salvos na extensão .R. Os scripts desse modo são um conjunto de texto que serão interpretados pelo computador como “coisas” a serem feitas (como calcular uma média através do comando mean()), e esses textos chamaremos de sintaxe, pois é a maneira através da qual vamos nos comunicar com o computador. Os scripts, junto com variáveis e funções, possibilitam evitar a repetição mecânica dos comandos, um exemplo trivial para ilustrar o ponto é o cálculo da índice de massa corporal (IMC), podemos calcular comuma calculadora através da fórmula \\[IMC =\\frac{peso(kg)}{altura(metros)^2}\\]. Para calcular o IMC dos membros de sua família você pode anotar o peso e altura de cada um e calcular individualmente, ou então você pode escrever o seguinte código: &gt; peso &lt;- 65 &gt; altura &lt;- 1.75 &gt; &gt; IMC &lt;- peso/altura^2 &gt; IMC # [1] 21.22449 De modo que o que você precisa fazer é apenas mudar os valores do peso altura e executar o código novamente. Dois comandos são importantes você ter em mente sobre scripts: (i) Para abrir um novo script tem se usar o atalho ctrl+shift+n; e (ii) para salvar um script baste clicar no icone de disquete que aparece na aba embaixo de untitled1 na figura 1.3. Podemos dizer que os scripts substituiem os mouse e os botões por uma tela onde o usuário através dos comandos realiza suas análises da maneira mais livre possível. 1.4 Funcionamento do Código É importante entender o funcionamento da execução do código do R. Chamamos de código o conjunto de comandos que estão salvos em um script, onde cada comando representa uma ação que pedimos para a linguagem executar. Comandos podem ser simples como calcular a média de uma vetor ou podem ser mais complexos como retornar uma mensagem caso no número seja par e outra caso o número seja impar. O chunk abaixo mostra como seriam escritos os exemplos citados anteriror mente: &gt; ## Calculando média de um vetor &gt; vetor &lt;- rnorm(10) &gt; mean(vetor) &gt; &gt; ## Vendo se um número é impar ou par &gt; x &lt;- 13 &gt; if(x %% 2 == 0){ + print(&quot;x é par&quot;) + } else { + print(&quot;x é ímpar&quot;) + } O chunk possui ao todo 4 comandos, pois as linhas que começam com # são chamadas de comentários elas são executadas apenas como texto. O primeiro comando, vetor &lt;- rnorm(10), cria um vetor com 10 números aleatório, o segundo, mean(vetor), calcula a média dos elementos do vetor, o terceiro, x &lt;- 3, atribui à variável xo valor 3 e, por fim, o quarto comando, que começa no if(x %% 2 == 0), testa de x é par e retorna uma mensagem caso ele seja par e outra caso x seja ímpar. Para executar um comando utiliza-se o atalho no teclado ctrl+Enter e a linha em que você se encontra será executada, no caso dos três primeiros comandos é direto a execução com o atalho. Porém, se prestarmos atenção o quarto comando encontra-se “espalhado” em 5 linhas e aí reside um detalhe, note que sabemos que o comando tem mais de uma linha através do + que aparece nas três linhas subsequentes à primeira. O RStudio permite que você escolha entre duas opções de execução de comandos com mais de uma linha. A primeira opção é executar uma linha de cada vez, no nosso exemplo seria necessário utilizar o ctrl+Enter quatro vezes para executar o quarto comando. A segundo opção é fazer com que comandos com mais de uma linha sejam executados de uma só vez, neste caso para executar o quarto comando seria necessário utilizar p ctrl+Enter apenas na linha if(x %% 2 ==0) para executar o quarto comando. Independente de qual das opções foi utilizada para executar o código o resultado apóes executar os quatro comandos acima é apresentado na figura 1.4 Figure 1.4: Resultado Vemos que no console aparece o comando que foi executado, linhas que começam com &gt;, seguido pelo resultado do comando, linhas que começam com [1], o que acontece nos bastidores é que ao executar um comando no script esse comando é “jogado” para o console onde ele é executado. Por fim, vemos que no Environment estão salvos o vetor e a variável x. A escolha entre as duas maneiras de executar o código é uma escolha do usuário, pois o resultado final do código será o mesmo. Para optar pela execução de todas as linhas do comando de uma só vez acesse a aba \\(Tools\\Rightarrow Global\\ Options\\Rightarrow Code\\) e então marque a opção Execute all lines in a statement1, a figura 1.5 mostra o caminho completo. Figure 1.5: Opções de execução do código RStudio Um último detalhe para ae comentar sobre a execução dos códigos é que em boa parte dos comandos a execução do código é quase que instantanea, porém há situações em que o computador pode demorar para executar o código. Nessas situações é importante que você não execute nenhum outro comando enquanto o R não terminou de executar o comando anterior. Enquanto o R está executando um commando aparece uma “placa” no canto superior direito do console escrito stop, destacado na figura 1.6. Ao terminar de executar o código essa “placa” sumirá. Um exemplo de comando tende a demorar (relativamente) a ser executado é a estimação dos modelos de controle sintético apresentados por Abadie, Diamond, and Hainmueller (2010). Passamos agora a discussão para entender onde o R “vive”, isto é, qual a maneira como o R interaje com o computador, no sentido de buscar arquivos para serem trabalhados dentro do R ou salvar resultados que foram obtidos no R. 1.5 Working Directory (ou pasta de trabalho) O jeito mais comum de se organizar um trabalho que envolva análise dados (seja projeto de pesquisa, trabalho da universidade etc.) é através de pastas no computador. É comum que os dados que serão analisados tenham de ser importados para dentro do R (colocar aqui referencia da seção), ou então que você queira salvar um plot que foi gerado dentro do R, o working directory nada mais é do que a pasta no seu computador onde o R vai buscar os arquivos para serem importados e salvar os resultados que serão exportados. Há duas funções que você precisa conhecer no que tange à pasta de trabalho. A primeira é para definir a pasta de trabalho e chama-se setwd(), onde wd é abreviação de working directory o único argumento que essa função leva é o caminho da pasta entre aspas, como o exemplo abaixo: &gt; setwd(&quot;C:/Users/Vinicius/Desktop/working directory&quot;) É importante notar que as barras são inclinadas para a direita e que o endereço começa no disco em que se encontra a página, pode parecer bobeiras, mas são erros comuns nos primeiros contato com o R. Para copiar o endereço de uma pasta basta clicar com o botão direito e selecionar a opção copiar, como se fosse qualquer outro arquivo, e depois colar denteo da função setwd(). A segunda função importante para se saber é a getwd(), você consegue adivinhar o que ela faz? Isso mesmo, a função mostra para você qual é a pasta na qual o R está “vivendo” atualmente e ela não possui nenhum argumento. Por exemplo, este livro foi escrito dentro do RStudio e no momento o working directory é a pasta: &gt; getwd() # [1] &quot;C:/Users/Vinicius/Dropbox/projects/livro_r&quot; Na seção (colocar aqui seção de boas praticas script) iremos discutir boas práticas em relação ao script e working directory, mas vale a pena destacar adiantar uma boa prática. Como dito anteriormente é comum organizarmos nossos trabalhos acadêmicas em pastas, então suponhamos que estejamos fazendo um trabalho de econometria sobre o clássico exemplo de renda e consumo, estou assumindo que no nosso computador há uma pasta onde encontram-se os dados que o professor passou (ou você obteve), possíveis arquivos de texto e etc. É uma boa prática você criar dentro dessa pasta uma outra pasta e usá-la como working directory. 1.6 Pacotes (ou libraries) Em todas as esferas da análise de dados (importar dados, manipular dados, estimar modelos/testes estatísticos e reportar resultados) no R trabalha-se com funções que nos auxiliam, setwd() e mean() são duas funções já apresentadas. O R possui várias funções built in, isto é, que ao instalar o programa as funções já estão disponíveis. Um pacote neste contexto nada mais é do que um conjunto de funções sobre um tema parecido que não são carregadas autimaticamento ao abrir o RStudio. Por exemplo, no capítulo @ref(intrpducao_ao_ggplott2) vamos mostrar o básico do pacote ggplot2 que é um pacote desenvolvido para viasualização de dados e contém funções para histogramas, boxplots, gráficos de densidade 2d etc. Para instalar um novo pacote utiliza-se a função install.packages(&quot;nome do pacote&quot;), isso instala no seu computador as funções que estão no pacote, mas não as deixa disponíveis para utilização. Para fazer isso é necessário que você carrege as funções para o R através do comando library(nome do pacote). Ao instalar um pacote uma aba com o progresso abrirá mostrando qual o status da instalação, como mostrado na figura 1.6. Figure 1.6: Status de instalação de pacote Duas observações: (i) note que ao instalar o pacote o nome do pacote deve estar entre aspas e ao carregar o nome do pacote está sem aspas; (ii) **só é necessário instalar o pacote uma vez no seu computador (a primeira vez que você for utilizá-lo), mas é necessário que você carrege o pacote sempre que vocÊ abrir o R. Exercise 1.1 (Instalar o pacote tidyverse) O pacote tidyverse será muito utilizado ao longo do livro e das suas atividades dentro do R. Esse pacote é na verdade um conjunto de pacotes que modernizaram e deixaram de maneia mais natural fazer as atividades relacionadas à analise de dados no R. Isto é, ele tem funções de manipulação de dados, visualização, estimação, programação etc. Seu exercício é instalar corretamente esse pacote. Pacotes do GitHub Para fins deste livro podemos descrever o GitHub como uma “nuvem” (do mesmo jeito que o google drive, icloud etc.), mas para códigos de programação2. Desse modo é possível que pacotes para o R sejam criando e colocados a disposição para os usuários no GitHub. E neste caso a instalação do pacote é um pouco diferente. Para instalar um pacoite que encontra-se no GitHub utiliza-se a função install_github(&quot;usuario/pacote&quot;). onde usuário é o nome do usuário que fez o pacote no GitHub e pacote é o nome do pacote. Entretando a função install_github pertence ao pacote devtools. Ou seja, para instalar um pacote do GitHub você deve ter instalado no computador o pacote devtools, que é instalado como mostrado em 1.6. Exercise 1.2 (Pacote com dados usados no livro) Os dados que serão utilizados nos exercícios e exemplos do livro estão disníveis em um pacote que encontra-se no GitHub, deste modo seu exercício agora é instalar e carreare o pacote devtools para poder ter acesso a função install_github. Em seguida baixe o pacote “DadosLivroR” do usuário “vinisousa04” com a função install_github. References "],
["primeiros-comandos-no-R.html", "2 Primeiros Comandos no R 2.1 R como calculadora 2.2 Workspace/Environment 2.3 Funções 2.4 Ajuda e documentação", " 2 Primeiros Comandos no R Agora que apresentamos o R e RStudio e o básico sobre seu funcionamento, vamos começar nossa aventura dentro das linhas de comando do R apresentando… Neste capitulo usaremos os os pacotes &gt; library(tidyverse) &gt; library(DadosLivroR) 2.1 R como calculadora A utilização mais trivial que se pode fazer do R é como uma calculadora. Onde podemos fazer operações “comuns”, como soma, multiplicação, exponenciação e etc. A execução das operações comuns é muito intuitiva, se quisermos somar números utilizamos o símbolo +, dividir usamos /, exponenciação usamos ^. Porém há outros tipos de operações3 que podemos fazer que isoladamente são simples, mas que são muito úteis no processo de análise de dados. O primeiro tipo é o que chamamos de testes de igualdade. São operações que testam se duas variáveis são iguais, se uma é menor ou maior que a outra. Diferente das operações comuns que retornam valores númericos, essa operações retornam valores lógicos de TRUE para verdadeiro e FALSE para falso, valores lógicos são apresentados devidamente na seção @ref(tipos_de_dados). Então ao executar o comando 2 == 3 o resultado exibido será FALSE e ao executar o comando 2 &lt;= 3 retornará um resultado TRUE, pois é claro que 2 não é igual a 3 e é menor que 3. Como pode se verificar abaixo &gt; 2==3 # [1] FALSE &gt; 2&lt;=3 # [1] TRUE Isso pode parecer bobo, mas toda a estatística que tradicionalmente se aprende em um curso de graduação4 é baseado em testes de hipótese que em termos práticos é verificar se o p valor de uma estatística é menor do que \\(1-nível\\ de\\ significância\\ escolhido\\)5. Ou seja, podemos automatizar decisões através de testes de igualdade. O outro tipo de operação é chamada de connectivos/operadores lógicos. Da mesma maneira que os testes de igualdade os operadores lógicos retornam valores TRUEou FALSE. Há três operadores importantissímos, são eles o E que retorna TRUE caso as duas condições sejam verdadeiras e FALSE caso contrário. O OU que retorna TRUE caso uma das duas condições seja verdadeira e FALSE caso contrário. E o negação que retorna TRUE caso a condição seja falsa e FALSE caso a condição seja verdadeira. É importante parar um pouco e refletir sobre o que isso significa para ter certeza que você entendeu, e para ajudá-lo a compreendeer e mostrar os símbolos dos operados no R vamos analisar um exemplo detalhado. A tabela 2.1 traz resumidamente os principais operadores do R. Table 2.1: Principais Operadores do R Operação Descrição Resultado x + y Soma y ao x Número x - y Subtrai y de x Número x * y Multiplica x, y vezes Número x / y Divide x por y Número x ^ y Eleva x à y potência Número x == y Testa se y é igual a x TRUE/FALSE x &lt;= y Testa se y é menor ou igual a x TRUE/FALSE x &gt;= y Testa de y é maior ou igual a x TRUE/FALSE x &amp; y Operador lógico ‘E’ TRUE/FALSE x | y Operador lógico ‘OU’ TRUE/FALSE !x Operador lógico de negação TRUE/FALSE Example 2.1 (Utilização dos operadores de teste e lógicos) O principal objetivo deste exemplo é mostrar uma aplicação de como os operadores de teste e lógicos são usados no precessso dentro do R para facilitar o processo de análise de dados. A motivação do exemplo será mostrar comparar a percepção da corrupção na América Latina e Caribe com a percepção de corrupção na África Subsahariana. Espeficicamente vamos usar o índice de percepção de corrupção para os anos de 2006 a 2015, sem os anos de 2007 e 2009 para verificar se a percepção de corrupção na América latina é maior ou menor do que na África e verificar se há algum comportamente em comum ao longo do tempo nas médias de percepção de corrupção. O índice de percepção de corrupção varia entre 0 e 100 e quanto mais próximo de 100 menor é a percepção de corrupção. O exemplo pode ser desmontado nos seguintes passos: (i) carregar pacotes; (ii) Selecionar dados; (iii) Filtrar os dados; (iv) Criar variaveis que queremos; e (v) Ver os resultados Vamos carregar os pacotes que usaremos: &gt; library(tidyverse) &gt; library(DadosLivroR) Agora vamos selecionar o data set chamada data_set1 do pacote DadosLivroR e visualizar o início dele. Para obter uma descrição do data set digite ?data_set1 no console. Ainda não apresentamos a função &lt;-, mas a grosso modo sempre que você se deparar com x &lt;- 2 leia como “x recebe 2”, onde vamos chamar o que estiver o lado esquerdo do &lt;- de “objeto daqui para frente. No caso do chunk abaixo seria”dados recebe data_set1“, desse modo você pode usar o data_set1 sempre que precisar chamando o objeto dados. &gt; # pegando os dados &gt; dados &lt;- data_set1 &gt; &gt; head(dados) # # A tibble: 6 x 9 # Pais Regiao Ano PerCap_dolar PerCap_growth Inflacao CPI PFI DI # &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Afgh~ South~ 2006 398 2.20 7.25 NA 44.2 3.06 # 2 Afgh~ South~ 2008 445 1.04 30.6 15.0 59.2 3.02 # 3 Afgh~ South~ 2010 553 5.43 0.893 14.0 51.7 2.48 # 4 Afgh~ South~ 2011 569 2.88 10.2 15.2 74.0 2.48 # 5 Afgh~ South~ 2012 630 10.8 7.22 8.00 74.0 2.48 # 6 Afgh~ South~ 2013 622 - 1.37 7.65 8.00 37.4 2.48 Em seguida vamos filtrar os dados e selecionar as variaveis que iremos trabalhar. Vamos selecionar as regiões da américa latina e África subsahariana e as variaveis relacionadas à região, ao ano e CPI que é índice de percepção de corrupção. O código abaixo faz isso: &gt; filtrado &lt;- dados %&gt;% + filter(Regiao == &quot;Latin America &amp; Caribbean&quot; | Regiao == &quot;Sub-Saharan Africa&quot;) %&gt;% + select(Regiao, Ano, CPI) Onde tiver %&gt;% leia “então”. Deste modo o chunk acima está fazendo o seguite: pegando o objeto dados, então filtrando a coluna Regiao para valores que sejam iguais à “Latin America &amp; Caribbean” OU iguais à “Sub-Saharan Africa”, então selecionando as colunas com o nome de Regiao, Ano e CPI e salvando o resultado em um objeto chamado filtrado. Veja que aqui utilizamos o operador lógico OU para fazer o filtro, filter(Regiao == &quot;Latin America &amp; Caribbean&quot; | Regiao == &quot;Sub-Saharan Africa&quot;)! Antes de prosseguirmos, vamos verificar o data frame filtrado: &gt; filtrado # # A tibble: 496 x 3 # Regiao Ano CPI # &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; # 1 Sub-Saharan Africa 2006 22.0 # 2 Sub-Saharan Africa 2008 19.0 # 3 Sub-Saharan Africa 2010 19.0 # 4 Sub-Saharan Africa 2011 20.1 # 5 Sub-Saharan Africa 2012 22.0 # 6 Sub-Saharan Africa 2013 23.0 # 7 Sub-Saharan Africa 2014 19.0 # 8 Sub-Saharan Africa 2015 15.0 # 9 Latin America &amp; Caribbean 2006 29.0 # 10 Latin America &amp; Caribbean 2008 29.0 # # ... with 486 more rows Vemos que temos o que queremos. Agora basta calcularmos as médias de cada ano para cada uma das regiões e depois a média geral de cada grupo: &gt; resultado &lt;- filtrado %&gt;% + group_by(Ano, Regiao) %&gt;% # agrupando por Ano e Regiao + summarise(media_ano = mean(CPI,na.rm = T)) %&gt;% # Calculando media + group_by(Regiao) %&gt;% # Agrupando por regiao + mutate(media_periodo = mean(media_ano), # criando media por ano + `menor que periodo` = if_else(media_ano &lt;= media_periodo, &quot;sim&quot;, &quot;Não&quot;)) Que resulta no seguinte: Ano Regiao media_ano media_periodo menor que periodo 2006 Latin America &amp; Caribbean 33.20833 35.59501 sim 2006 Sub-Saharan Africa 28.31429 30.70347 sim 2008 Latin America &amp; Caribbean 34.45833 35.59501 sim 2008 Sub-Saharan Africa 28.57895 30.70347 sim 2010 Latin America &amp; Caribbean 34.52174 35.59501 sim 2010 Sub-Saharan Africa 28.42105 30.70347 sim 2011 Latin America &amp; Caribbean 33.44666 35.59501 sim 2011 Sub-Saharan Africa 29.01819 30.70347 sim 2012 Latin America &amp; Caribbean 37.54167 35.59501 Não 2012 Sub-Saharan Africa 33.21053 30.70347 Não 2013 Latin America &amp; Caribbean 36.79167 35.59501 Não 2013 Sub-Saharan Africa 32.44737 30.70347 Não 2014 Latin America &amp; Caribbean 37.58333 35.59501 Não 2014 Sub-Saharan Africa 33.05405 30.70347 Não 2015 Latin America &amp; Caribbean 37.20833 35.59501 Não 2015 Sub-Saharan Africa 32.58333 30.70347 Não Neste último chunk pegamos o objeto filtrado, então agrupamos por Ano e Regiao, então calculamos a média do CPI (índice de percepção de corrupção), então agrupamos por Regiao, então adicionames duas variáveis: (i) media_periodo que tem a média do CPI para todo o período de cada região; e (ii) menor do que período que diz se a média no ano específico é menor ou não do que a média geral. E perceba que na última linha usamos o teste de igualdade para computar o valor da última variável,if_else(media_ano &lt;= media_periodo, &quot;sim&quot;, &quot;Não&quot;), o que essa linha fez comparar linha por linha se o valor da coluna “media_ano” é menor que o o valor “media_periodo” e caso o valor fosse menor então a coluna “menor que periodo” recebia o valor “sim” na respectiva linha, caso não fosse recebia o valor “não”! Não se preocupe em entender os detalhes do código, pois cada uma das ferramentas utilizadas serão propriamente apresentadas no decorrer do livro. O importante é que tenha ficado claro como os operados de teste e lógicos são utilizados. Outra coisa, pode parecer que é muito código, em um script seria apenas algo do tipo: &gt; library(DadosLivroR) &gt; library(tidyverse) &gt; &gt; # Pegar dados &gt; &gt; dados &lt;- data_set1 &gt; &gt; resultado &lt;- dados %&gt;% + filter(Regiao == &quot;Latin America &amp; Caribbean&quot; | Regiao == &quot;Sub-Saharan Africa&quot;) %&gt;% + select(Regiao, Ano, CPI) %&gt;% + group_by(Ano, Regiao) %&gt;% + summarise(media_ano = mean(CPI,na.rm = T)) %&gt;% + group_by(Regiao) %&gt;% + mutate(media_periodo = mean(media_ano), + `menor quegeral` = if_else(media_ano &lt;= media_periodo, &quot;sim&quot;, &quot;Não&quot;)) Vamos agora apresentar para o usuário como acessar os dados e variáveis que o leitor importa para o R. 2.2 Workspace/Environment Para entendermos o que é o Workspace/Environment vamos antes apresentar oficialmente o operador de atribuição &lt;-. A utilizaçãp desse operador da-se da seguinte maneira nome &lt;- objeto, onde nome é nome do objeto6 que você quer salvar. Se olharmos o exemplo 2.1 vemos que utilizamos o operador de atribuição três vezes para salvar os objetos dados, filtrado e resultado, ou seja nesse caso nossos objetos são data sets, mas poderiam ser várias outras coisas, como vetores, resultados de regressão, gráfico e etc. Se olharmos o Workspace/Environment depois de executar o código do exemplo teremos algo como mostra a 2.1. Veja que temos nossos três objetos disponíveis para quando quisermos utiliza-los. Figure 2.1: Exemplo de workspace/Environment Ao clicar com o botão esquerdo do mouse nas janelinhas no final da linha com o nome do objeto é aberta uma nova aba dentro do RStudio mostrando os dados. Veja a figura 2.2. Figure 2.2: Vendo dados no RStudio 2.3 Funções De maneira simples uma função é um meio de se automatizar uma sequência de comandos. Isso é feito através de inputs (ou argumentos) e outputs, onde os inputs são valores que o usuário fornece à função e os outpus são os valores retornados pela função, a sintaxe geral de uma função é noma_da_função(argumentos). Um exemplo trivial é a função mean() que calcula a média de um determinado conjunto de número. Qual são os comandos que essa função automatiza? (i) somar cada elemento do conjunto, (ii) contar quantos elementos tem o conjunto e (iii) dividir a soma pelo númere de elementos. Desse modo, calcularíamos amédia da sequência 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 da sequinte maneira: &gt; mean(1:10) # [1] 5.5 Neste caso o input foi a sequência de números 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 e o output foi o número 5.5. Este é um exemplo trivial que funciona para mostrar como as funções funcionam, entretanto deve se ter claro em mente que há funções para desempenhar uma grande variedade de comandos dos mais simples, como calcular média, à complexos como estimar modelos de controle sintético7. Ao abrir o RStudio várias funções são carregadas automaticamente, vamos chamar essas funções de funções built-in, porém uma das vantagens de softwares estatísticos gratuitos é que qualquer pessoa pode escrever funções e torna-las disponíveis através de pacotes. Como vimos na seção 1.6 utilizamos o comando library() para carregar algum pacote e ao carregar um pacote estamos basicamente tornando disponível um conjunto de funções e dados para utilizarmos. Então, ao carregar o pacote DadosLivroR fizemos o data set data_set1 disponível para utilização e ao carregar o pacote tidyverse tornamos a funções filter() disponível para usarmos. Destacamos aqui para os alunos de economia que nos últimos anos tem sido desenvolcidos pacotes que com funções que permitem acessar as principais fontes de dados econômicos do Brasil, como o sistema gerenciador de séries temporais do banco central, IBGE, SIDRA, FGV etc. Tais pacotes e funções serão apresentados na seção ??. Ao longo do livro o leitor será exposto a várias funções que executam comandos relacionados à todos os campos da análise de dados e conforme o leitor for utilizando o R o conhecimento das funções vai sendo acumulado e tornando cada vez mais eficiente a utilização do R como ferramente de análise de dados. 2.4 Ajuda e documentação Até este ponto do livro apenas mostramos situações nas quais os comandos foram executados sem que houvesse nenhum erro, mas essa nem sempre será o caso quando o leitor estiver usando o R. É claro que não vamos escrever um código que contenha erros de propósito, porém você irá escrever códigos com erros e saber como lidar com os erros é uma das habilidades essenciais para se utilizar o R de maneira eficiente. …saber como lidar com os erros é uma das habilidades essenciais… pode parecer frase auto ajuda, mas no caso do R quando nos referimos a saber como lidar com os erros estamos querendo dizer que devemos encontrar o erro, diagnosticar e resolve-lo. Há uma infidade de possíveis erros que podem acontecer de modo que qualquer tentativa de uma solução geral é completamente inútel, o que vamos buscar fazer aqui é apresentar o “como” ocorrem os erros de modo que, entendo a maneira pela qual ele ocorre, fica mais fácil buscar as soluções. Outra coisa importante de se ter em mente é que entender um pouco de inglês ajuda (e muito) na hora de procurar ajuda e ler a dicumentação de qualquer linguagem de programação, e o R não foge disso. Por isso, algumas partes dessa sessão terão conteúdo em inglês (conforme o usuátio encontraria na internet). 2.4.1 Erros, Mensagens e Avisos Erros Ao executar um comando que contenha algum erro de sintaxe aparecerá no console do RStudio uma mensagem de erro e o leitor deve considerar essa mensagem como sendo o primeiro lugar para se procurar ajuda, pois em boa parte dos casos a mensagem explicará de maneira compreensível qual foi o erro. O chunk abaixo mostra isso: &gt; &quot;tres&quot; + 2 # Error in &quot;tres&quot; + 2: non-numeric argument to binary operator Ao tentar somar um pedaço de texto com um número o R retorna a mensagem Error in &quot;tres&quot; + 2 : non-numeric argument to binary operator. A operação de soma só funciona com valores númericos no R, de modo que ao executar o comando o R percebeu que um dos valores da operação binária8 era um pedaço de texto e então retornou o erro. infelizmente não será sempre que vamos descobrir qual é o erro através das mensagens de erro, veja por exemplo ao tentar carregar para dentro do R a série história do IPCA (Índice Nacional de Preços ao Consumidor Amplo) do Sistema Gerenciador de Séries Temporais do Banco Central podemos nos deparar com o seguinte resultado &gt; library(rbcb) # carregando o pacote com a função get_series &gt; get_series(code = 433) # Error in curl::curl_fetch_memory(url, handle = handle): Couldn&#39;t resolve host name Algo que pode ser feito é copiar e colar a mesangem de erro no em alguma ferramenta de busca (isso o google). Ao colar essa mensagem de erro no google um dos links que aparece é este https://support.rstudio.com/hc/en-us/community/posts/115000629548-Error-in-CURL, que no final da página tem como resposta dizendo que essa mensagem de erro está relacionada a problemas de conectividade com a internet. Neste momento que entra a importância do inglês, pois há diversas comunidades de perguntas e repostas sobre erros do R, grande parte delas em inglês e ao utilizar esse meio de resolver os problemas o usuário irá com o passar do tempo verificando qual é a sua comunidade favorita. Mensagens falar primeiro da documentação e depois dos erros e mensagens em subseções diferentes tópicos para incluir usar “?” para ver documentação função example para ver como a função funciona “a duvida que você tem, não só alguém já teve, como alguem já postou na internet e outro alguém já respondeu” explicar em detalhes a diferença entre erro, warning e message que sai no console e como devemos ler para que possamos entender o que está acontecendo Estamos chamando de operações pois é uma maneira mais direta de se entender, sob uma perspectiva formal matemática seria incorreto utilizar essa nomeclatura↩ Estatística inferentista↩ Colocar aqui explicação sobre o significado do alpha e intervalo de confiança em termos dos tipos de erro I e II↩ Ressaltamos aqui que o termo objeto não tem a mesma conotação que teria no caso de liguagens orientadas a objetos↩ Veja Abadie, Diamond, and Hainmueller (2010) para mais detalhes↩ Operação binária quer dizer que são necessários dois elementos para que ela ocorra, em contrapartida operações unitárias necessitam apenas de um elemente para que ela ocorra. Precisamos de dois números para que eles sejam somados (mesmo que eles sejam iguais), mas precisamos apenas de um número para termos um valor absoluto↩ "],
["estruturas-de-dados.html", "3 Estruturas de Dados 3.1 Tipos de dados 3.2 Vetores 3.3 Matrizes 3.4 Data Frames 3.5 Listas 3.6 resumo (melhorar nome)", " 3 Estruturas de Dados Neste capítulo vamos apresentar ao leitor os tipos de dados e estruturas de dados fundamentais do R. Nota-se que não são apresentados todos os tipos e estruturas de dados, entretanto garantimos que os aqui apresentados serão o suficiente para resolver quase todos (se não todos) os problemas e aplicações que o leitor se deparar com. Também ressalvamos que talvez esse capítulo seja o mais importante desta parte do livro, pois um bom entendimento sobre os tipos de informações e como elas são armazenadas (dentro do R) é essencial para o desenvolvimento de habilidades para lidar com dados. Ressaltamos que o objetivo deste capítulo é fazer com o que leitor saiba “quais são e como são”&quot; as estruturas de dados, pois as ferramentas de “como trabalhar” com as estruturas de dados serão apresentadas ao longo do livro. Sem mais delongas os tipo de dados são como uma determinada informação pode ser registrada e já as estruturas de dados são como as informações são armazenadas de modo que possam ser utilizadas, um pouco abstrata essa explicação até agora não acham? Bem, uma analogia que pode ajudar a compreender a diferença entre tipos de dados e estruturas de dados é a seguinte: Acredito que seja familiar a todos o final do filme Toy Story (o primeiro da trilogia), quando o Woody e o Buzz perdem o caminhão da mudança contratado pela Mãe do Andy (digo mãe e não família pois o Pai do Andy é um mistério). Bem se recordarmos bem alguns brinquedos o Andy trouxe com ele dentro do carro (em especial teria trazido o Woody e o Buzz) e ao mesmo tempo outro brinquedos estavam sendo transportados no caminhão. Onde eu quero chegar com isso? Os brinquedos seriam um tipo de informação (no caso de uma mudança poderíamos pensar que as roupas seriam outro tipo de informação) e o caminhão da transportadora e o carro da mão do Andy seriam as diferentes estruturas nas quais é possível carregar os dados. Com a diferença entre tipos e estruturas de dados explicada vamos agora apresentar ao leitor explicitamente o funcionamento de tais coisas no R. Começamos apresentando os tipos de dados e em seguida as estrutura. 3.1 Tipos de dados Para apresentar os diferentes tipos de como as informações podem ser armazenadas vamos utilizar uma base fictícia de empregados apresentada na tabela 3.1. Nela temos 6 colunas representando diferentes variáveis. Table 3.1: Empregados Nome Tempo_emprego Setor Peso Nascimento Casado Mia 1 Financeiro 40.37 1999-06-23 TRUE William 2 Financeiro 44.75 1999-11-07 TRUE Gregory 3 Estrutura 38.40 1999-10-01 FALSE Amanda 4 Estrutura 32.65 1999-03-30 TRUE Mahmood 5 Marketing 36.13 1999-01-21 FALSE Abigail 6 Marketing 40.85 1999-10-14 FALSE Tasina 7 Marketing 40.18 1999-06-01 TRUE Julian 8 Estrutura 41.39 1999-04-12 FALSE Devika 9 Estrutura 44.03 1999-12-30 TRUE Nicholas 10 Estrutura 39.43 1999-04-14 FALSE Cada coluna possui um tipo diferente de informação e cada informação é armazenada de um jeito diferente. A lista abaixo sintetiza os tipos de dados e a coluna da tabela com a qual ela está relacionada9. Character (ou string): São caracteres textuais que podem assumir qualquer valor. Na tabela é a coluna relaciona ao Nome. Os elementos dos vetores de caracteres devem estar entre aspas &quot;elemento&quot;; Integer: São números inteiros, neste caso relacionado com a coluna idade; Double: São números decimais, neste caso relacionado à coluna de peso; Factor: São caracteres textuais mais podem assumir somente um determinado tipo de valor. Neste caso seria a coluna que traz o setor no qual o empregado trabalha. Outro exemplo de factor seria o tipo sanguíneo em um banco de dados de pacientes; Dates: São valores textuais que são interpretados como datas, neste caso relacionado à coluna nascimento; Logical: Assumem o valor TRUE ou FALSE, também chamados de valores booleanos. A função str() permite verificar a estrutura dos nossos objetos, o chunk abaixo mostra a utilização da função na nossa base de dados de empregados &gt; str(empregados) # &#39;data.frame&#39;: 10 obs. of 6 variables: # $ Nome : chr &quot;Mia&quot; &quot;William&quot; &quot;Gregory&quot; &quot;Amanda&quot; ... # $ Tempo_emprego: int 1 2 3 4 5 6 7 8 9 10 # $ Setor : Factor w/ 3 levels &quot;Estrutura&quot;,&quot;Financeiro&quot;,..: 2 2 1 1 3 3 3 1 1 1 # $ Peso : num 40.4 44.8 38.4 32.7 36.1 ... # $ Nascimento : Date, format: &quot;1999-06-23&quot; &quot;1999-11-07&quot; ... # $ Casado : logi TRUE TRUE FALSE TRUE FALSE FALSE ... Seguindo na nossa analogia da mudança as estruturas de dados seriam os meios através dos quais podemos transportar os objetos de uma casa para outro, como carros, caminhões etc. Deste modo, nesta seção vamos apresenta ao leitor o que são e exemplos de como construir: (i) Vetores, (ii) Matrizes, (iii) Data frames e (iv) Listas 3.2 Vetores É a estrutura mais básica (e fundamental) do R. De maneira objetiva um vetor é uma sequência de elementos do mesmo tipo. Agora vamos introduzir aqui 4 aspectos importantes sobre vetores. Criando Vetores Há diversas maneiras de se criar vetores e a sua imaginação é de fato o limite, porém há jeitos mais triviais que são muito utilizados. Dois destes triviais são através da função concatenar, c(), e a função sequência, seq(). O chunk abaixo ilustra maneiras diferentes de se criar a sequência 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. &gt; c(1,2,3,4,5,6,7,8,9,10) # [1] 1 2 3 4 5 6 7 8 9 10 &gt; c(1:10) # [1] 1 2 3 4 5 6 7 8 9 10 &gt; seq(from = 1, to = 10, by=1) # [1] 1 2 3 4 5 6 7 8 9 10 &gt; seq(from = 1, length.out = 10,by = 1) # [1] 1 2 3 4 5 6 7 8 9 10 Quando quisermos salvar um determinado vetor em um objeto x, basta utilizarmos o operador de atribuição &lt;- da seguinte maneira x &lt;- c(1:10). A lógica é a mesma para criar vetores com outros tipos de dados, como por exemplo criar um vetor contendo as primeiras letras do alfabeto e outro com os primeiros dias de 2017. &gt; letras &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;) &gt; letras # [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &gt; dias &lt;- seq(from = as.Date(&quot;01/01/2017&quot;,format=&quot;%d/%m/%Y&quot;),length.out = 5,by = &quot;day&quot;) &gt; dias # [1] &quot;2017-01-01&quot; &quot;2017-01-02&quot; &quot;2017-01-03&quot; &quot;2017-01-04&quot; &quot;2017-01-05&quot; Não se preocupe caso não tenha ficado claro a sintaxe do vetor dias, mais para frente vamos discutir em maior detalhe datas10 Acessando elementos Acessar elementos específicos de vetores é algo muito útil (acreditem no que eu digo) e fácil, basta utilizar x[i], onde x é um vetor e i o i-ésimo elemento11. No chunk abaixo segue mostro alguns exemplos de como acessar elementos dos vetores &gt; x &lt;- c(1:10) # criando um vetor x &gt; x[7:9] # pegando elementos de 7 a 9 # [1] 7 8 9 &gt; x[length(x)] &lt;- 0 # substituindo o último elemento por 0 &gt; y &lt;- x[1:4] A última linha do chunk acima crian um novo vetor y com os 4 primeiros valores do vetor x, ou seja, mais um jeito de se criar vetores. Mais adiante no livro12 mostraremos que os filtros utilizados nos dados (como por exemplo selecionar de um banco de dados apenas os pacientes com pressão arterial acima de 140 X 90 mmHg) nada mais é do que acessar elementos do vetores que satisfaçam de terminadas condições. Operações Vetorizadas Dizer que as operações são vetorizadas é apenas dizer que ao aplicar uma funções em um vetor essa função será aplicada em cada um dos elementos do vetor. Daí inclusive a importância de internamente o R não aceitar vetores com tipos de informação diferentes, pois não faria sentido, por exemplo, efetuar a multiplicação em um vetor que contem letras!! A ideia é bastante simples e intuitiva, porém não custa nada visualizar alguns exemplos. &gt; a &lt;- c(1,4,9,16,25,36,49,64,81) &gt; sqrt(a) # sqrt é a raiz quadrada # [1] 1 2 3 4 5 6 7 8 9 &gt; a+1 # [1] 2 5 10 17 26 37 50 65 82 Perceba que cada vez que uma função é aplicada no vetor ela na verdade é aplicada em cada elemento que compõe o vetor. O último aspecto importante para se introduzir sobre vetores é a reciclagem. Reciglagem O que você imagina que acontece quando a operação c(1,2)+c(1,1,1,1) é efetuada? O nome da subseção já da uma boa dica. O que acontece é que o vetor de menor comprimento é reciclado, isto é, reutilizado, para que a operação seja efetuada e resultando no seguinte vetor c(2,3,2,3). Importante salientar que isso ocorre quando comprimento do maior vetor é múltiplo do comprimento do vetor menor, caso não seja este caso será retornado um erro. O chunk abaixo explicita essas duas situações &gt; c(1,1)+c(1,2,1,2) # [1] 2 3 2 3 &gt; c(1,1)+c(1,2,1,2,1) # [1] 2 3 2 3 2 3.3 Matrizes A segunda estutura apresentada é a matriz, que nada mais é do que uma extensão do vetor para uma dimensão a mais. Colocando de outro jeito uma matriz é uma estrutura com colunas com o mesmo número de linhas e que armazenam o mesmo tipo de informação. O leitor provavelmente já se deparou em algum momento da vida com uma matriz do seguinte formato &gt; matrix(data = letters[1:6],ncol=3) # [,1] [,2] [,3] # [1,] &quot;a&quot; &quot;c&quot; &quot;e&quot; # [2,] &quot;b&quot; &quot;d&quot; &quot;f&quot; Assim como foi feito com vetores, vamos mostrar como criar matrizes do zero, como acessar seu elementos e por fim como discutiremos a título de informação, não se preocupem, sobre operações matemática com matrizes. Criando Matrizes Para criar matriz utilize a função de nome matrix(), que surpresa, na qual são necessários no mínimo dois argumentos. O argumento data para o qual deve ser passado um vetor que irá popular a matriz e o segundo argumento necessário é ou ncolou nrow, especificando claramente o número de colunas ou o número de linhas. Perceba que é importante que o vetor passado para data tenha um comprimento compátivel com o número de linhas ou número de colunas. Abaixo tem o exemplo de como criar uma matriz &gt; matriz_simples &lt;- matrix(data = c(1:25),nrow = 5,byrow = TRUE) &gt; matriz_simples # [,1] [,2] [,3] [,4] [,5] # [1,] 1 2 3 4 5 # [2,] 6 7 8 9 10 # [3,] 11 12 13 14 15 # [4,] 16 17 18 19 20 # [5,] 21 22 23 24 25 O terceiro argumento byrow recebe um valor lógico, e tem como default FALSE e como o nome diz ele indica se a matriz deve ser preenchida por linhas, byrow=TRUE ou por colunas. Perceba que na primeira matriz apresentada nesta seção não tem o esse argumento e por consequência a matriz foi preenchida por colunas. Acessando Elementos Como a matriz é uma extensão dos vetores a ideia é a mesma, com a única diferença que é necessário diferenciar o indexador de linha e de coluna. E isso é feito de maneira muito simples e direta com o operador [], da seguinte maneira: matriz[i,j] onde i denota as linhas e j denota as colunas. Caso quiséssemos pegar somente os elementos das duas primeiras linhas e das duas últimas colunas da matriz_simples uma maneira seria &gt; matriz_simples[-c(3:5),c(4,5)] # [,1] [,2] # [1,] 4 5 # [2,] 9 10 Note que usamos -c(3:5) para indicar que queremos todas as linhas menos as linhas 3, 4, 5. O mesmo poderia ter sido feito para as colunas. Vale destacar uma sutileza importante para compreender a utilização de matrizes no R. Pode haver casos em que desejamos acessar apenas uma coluna (ou linha) específica de uma determinada matriz e acredito que a tentativa mais natural para todos seria algo como matriz_simples[,3], mas ao executar esse comando no console teríamos como resultado &gt; matriz_simples[,3] # [1] 3 8 13 18 23 Um vetor! E neste caso teríamos que nos perguntar: Queremos que o resultado da nossa operação (selecionar uma ou coluna especifica) seja um vetor ou uma matriz coluna (ou linha)? Caso a resposta seja um vetor deve ser executado o comando como acima, porém caso não seja esse o caso adicionamos o argumento drop=FALSE fazendo com que a estrutura de matriz seja preservada. &gt; matriz_simples[,3, drop = F] # [,1] # [1,] 3 # [2,] 8 # [3,] 13 # [4,] 18 # [5,] 23 Por fim, note que o resultado de não selecionar nenhuma coluna é selecionar todas as colunas, e o mesmo se aplica para colunas. E neste caso as operações que efetuarmos nas matrizes coluna ou linha serão automaticamente vetorizadas. Operações com matrizes Vamos aqui mostrar a título de informação algumas operações matemáticas com matrizes. Digo a título de informação, pois constatei na minha experiência que a utilização dessas operações é rara, porém acredito que seja importante saber da existência. Antes de mostarmos os procedimentos vamos criar duas matrizes para trabalharmos com elas, vamos criativamente chama-las matrix_1 e matrix_2. &gt; matrix_1 &lt;- matrix(data = 1:6,ncol = 3) &gt; matrix_2 &lt;- matrix(data = 1:6, ncol = 2) Multiplicação e Soma De maneira geral podemos nos deparar com dois casos: (i) queremos somar/multiplicar um número com/por uma matriz ou (ii) queremos multiplicar duas matrizes. Quando nos encontramos no primeiro (somar/multiplicar um número por um matriz) caso basta usar os operadores apresentados na seção colocar aqui a referencia para a seção R como calculadora e a operação é aplicada em cada elemento da matrix, como feito no chunk que segue &gt; 3+matrix_1 # [,1] [,2] [,3] # [1,] 4 6 8 # [2,] 5 7 9 &gt; 3*matrix_2 # [,1] [,2] # [1,] 3 12 # [2,] 6 15 # [3,] 9 18 &gt; sqrt(matrix_1) # [,1] [,2] [,3] # [1,] 1.000000 1.732051 2.236068 # [2,] 1.414214 2.000000 2.449490 Já no segundo caso (multiplicar matrizes) temos que colocar o operador * entre %s para que o R entenda que queremos efetuar operações matriciais &gt; matrix_1 %*% matrix_2 # [,1] [,2] # [1,] 22 49 # [2,] 28 64 É claro que as matrizes devem ter dimensões vpalidas para que a multiplicação seja efetuada. Determinante, Transposta e Inversa Brevemente vamos apresentar as funções para obtermos o determinante, a transposta e a inversa de uma matriz. Começamos com o determinante que é calculado através da função det(): &gt; matriz &lt;- matrix(c(1:4),ncol=2,byrow = T) &gt; det(matriz) # [1] -2 A transposta por sua vez é calculada através da função t(): &gt; t(matriz) # [,1] [,2] # [1,] 1 3 # [2,] 2 4 E por fim a inversa é obtida através da função solve(): &gt; solve(matriz) # [,1] [,2] # [1,] -2.0 1.0 # [2,] 1.5 -0.5 Passamos agora para a estrutura chamda de data frame, que funciona com os principios de vetores e matrizes, porém com algumas modificações que a tornam muito útil na prática. 3.4 Data Frames Os data frames possuem a mesma estrutura que uma matriz, isto é, colunas com o mesmo número de linhas. Porém, há duas vantagens de se trabalhar com data frames13: (i) Cada coluna pode contar tipos de informações diferentes e (ii) nomeando as colunas podemos acessar colunas específicas sem precisar saber exatamente a indexação da coluna. Essas duas diferenças tornam os data frames o jeito mais comum de se trabalhar com bases de dados no R. Pois podemos ter diversas variáveis, relacionadas a mesma observação, com tipos de informação diferente em uma mesma estrutura! O leitor atento percebeu que a tabela 3.1 é na verdade um exemplo de data frame, onde cada coluna representa uma variável com tipo diferente de informação. Para acessar colunas pelo nome utiliza-se o $ logo em seguida do nome do data frame. Caso quissésemos acessar só os nomes do nosso data frame de empregados poderíamos fazer da seguinte maneira: &gt; empregados$Nome # [1] &quot;Mia&quot; &quot;William&quot; &quot;Gregory&quot; &quot;Amanda&quot; &quot;Mahmood&quot; &quot;Abigail&quot; # [7] &quot;Tasina&quot; &quot;Julian&quot; &quot;Devika&quot; &quot;Nicholas&quot; O RStudio possui uma ferramenta conveniente para nos ajudar, ao digitar empregados$ e em seguida pressionar TAB o RStudio mostrará um menu dropdown com os nomes das colunas do data frame, como mostra a figura 3.1, de modo que não é necessário sabermos qual o número da coluna em que se encontra a variável de interesse e nem ter que saber de cabeça o nome de todas as variáveis disponíveis no data frame. Figure 3.1: Menu Dropdown do RStudio Outra utilidade do $ quando se tratando de data frames é adicionar novas variáveis ao data frame. Ainda no nosso exemplo do data frame com informações sobre os empregados, poderíamos pensar que foi oferecido aos empregados um treinamento no qual a participação é optativa e depois que o treinamento foi realizado gostaríamos de adicionar uma coluna indicando quais empregados optaram por participar do treinamento. Para facilitar o entendimento vamos supor que os 5 primeiros empregados () optaram por participar do treinamento e os últimos 5 por não participar. Desse modo queremos adicionar uma coluna com o nome de Treinamento que receberá o valor sim caso o empregado tenha participado do treinamento e não caso ele não tenha participado. Isso é feito da seguinte maneira: &gt; empregados$Treinamento &lt;- c(rep(&quot;sim&quot;,5),rep(&quot;não&quot;,5)) A sintaxe c(rep(&quot;sim&quot;,5),rep(&quot;não&quot;,5)) cria um vetor repetindo o termo sim cinco vezes e depois repetindo o termo não também cinco vezes. Agora se verificarmos nosso data frame veremos que a coluna Treinamento adicionada com sucesso. &gt; str(empregados) # &#39;data.frame&#39;: 10 obs. of 7 variables: # $ Nome : chr &quot;Mia&quot; &quot;William&quot; &quot;Gregory&quot; &quot;Amanda&quot; ... # $ Tempo_emprego: int 1 2 3 4 5 6 7 8 9 10 # $ Setor : Factor w/ 3 levels &quot;Estrutura&quot;,&quot;Financeiro&quot;,..: 2 2 1 1 3 3 3 1 1 1 # $ Peso : num 40.4 44.8 38.4 32.7 36.1 ... # $ Nascimento : Date, format: &quot;1999-06-23&quot; &quot;1999-11-07&quot; ... # $ Casado : logi TRUE TRUE FALSE TRUE FALSE FALSE ... # $ Treinamento : chr &quot;sim&quot; &quot;sim&quot; &quot;sim&quot; &quot;sim&quot; ... Destaco aqui que não mostro como criar data frame do zero, pois como mencionado no início desta seção, os data frames são muito utilizados para armazenar dados que serão importados para dentro do R (colocar aqui o capitulo que falará sobre importar dados para o R) e não digitados no console ou script. 3.5 Listas A última estrutura de dados é chamada de lista (ou vetor recursivo). De maneira objetiva a lista é um vetor no qual seus elementos podem ser qualquer outro tipo de estrutura, isto quer dizer que podemos ter uma lista que contém vetor, matrizes, data frames, listas e etc. Perceba que ao passo que o data frame tem colunas com o mesmo número de linhas as listas tem elementos que não só podem ter número de linhas diferentes como estruturas de dados diferentes! Caso a explicação até agora esteja um pouco abstrata, não se preocupe pois antes de entrarmos na discussão mesmo sobre listas vamos apresentar um exemplo de como as listas são realmente úteis e versáteis quando utilizamos o R. Example 3.1 (Versatilidade da Estrututa Lista) O objetivo desse exemplo é mostrar uma aplicação de como as listas são usadas dentro R, faremos isso mostrando que ao efetuar uma regressão no R os resultados são armazenados em uma lista. Para tal vamos utilizar o dataset gapminder (disponível no pacote gapminder) que é um excerto sobre dados de expectativa de vida, PIB per capita e população por país. Vamos construir um modelo do tipo log-log, para avaliar os efeitos em termos percentuais, onde a expectativa de vida depende do PIB percapita e do tamanho da população. A figura 3.2 traz o resultado da estimação da regressão. Perceba que a regressão, salva com o nome de reg, e o sumário da regressão, salvo como sumario_reg, são listas com 12 e 11 elementos respectivamente. E ao executar o sumário da regressão (linha 4) temos o resultado completo do sumário armazenado na lista. (Obs: não se preocupe em entender o código da figura, mais para frente colocar aqui a seção de sregressão iremos discutir em detalhes como fazer regressão no R). Figure 3.2: Ambiente com objeto regressão Espero que esse exemplo tenha ilustrado como as listas são versáteis e tenha facilitado o entendimento das mesmas, pois tenho certeza que o leitor irá se deparar em diversas situações com listas. Criando listas Para criar uma lista utiliza-se função list() onde os argumentos são os nomes dos elementos e os elementos em si. Uma lista simples pode ser criada da seguinte maneira: &gt; lista &lt;- list(nomes = empregados$Nome, + data_frame = empregados[1:4,-1], + lista = list(numeros=1:10,aleatorio=rnorm(4))) Veja que é possível ter listas como elementos de uma lista (por isso listas são também chamadas de vetores recursivos). Para visualizar a lista no console podemos executar o nome da listano conseole, neste caso lista, nos dando o seguinte resultado: &gt; lista # $nomes # [1] &quot;Mia&quot; &quot;William&quot; &quot;Gregory&quot; &quot;Amanda&quot; &quot;Mahmood&quot; &quot;Abigail&quot; # [7] &quot;Tasina&quot; &quot;Julian&quot; &quot;Devika&quot; &quot;Nicholas&quot; # # $data_frame # Tempo_emprego Setor Peso Nascimento Casado Treinamento # 1 1 Financeiro 40.37228 1999-06-23 TRUE sim # 2 2 Financeiro 44.75095 1999-11-07 TRUE sim # 3 3 Estrutura 38.40362 1999-10-01 FALSE sim # 4 4 Estrutura 32.65491 1999-03-30 TRUE sim # # $lista # $lista$numeros # [1] 1 2 3 4 5 6 7 8 9 10 # # $lista$aleatorio # [1] -0.86749760 -1.11188778 0.30293817 0.08144184 De modo que conseguimos visualizar e entender o que está dentro da nossa lista, porém em casos reais as listas são maiores e com objetos mais complexos e a melhor opção para entender a lista em questão é utilizar a função str(), que nos da o seguinte resultado &gt; str(lista) # List of 3 # $ nomes : chr [1:10] &quot;Mia&quot; &quot;William&quot; &quot;Gregory&quot; &quot;Amanda&quot; ... # $ data_frame:&#39;data.frame&#39;: 4 obs. of 6 variables: # ..$ Tempo_emprego: int [1:4] 1 2 3 4 # ..$ Setor : Factor w/ 3 levels &quot;Estrutura&quot;,&quot;Financeiro&quot;,..: 2 2 1 1 # ..$ Peso : num [1:4] 40.4 44.8 38.4 32.7 # ..$ Nascimento : Date[1:4], format: &quot;1999-06-23&quot; ... # ..$ Casado : logi [1:4] TRUE TRUE FALSE TRUE # ..$ Treinamento : chr [1:4] &quot;sim&quot; &quot;sim&quot; &quot;sim&quot; &quot;sim&quot; # $ lista :List of 2 # ..$ numeros : int [1:10] 1 2 3 4 5 6 7 8 9 10 # ..$ aleatorio: num [1:4] -0.8675 -1.1119 0.3029 0.0814 O output retornado no console da função str() nos mostra que o nosso objeto lista é uma lista de 3 elementos. Onde o primeiro elemento é o vetor nomes, o segundo elemento é um data frame com nome de data_framee o terceiro elemento é uma lista com dois elementos chamada de lista. Acessando elementos das listas De maneira geral há duas maneiras de acessar os elemtos de uma lista: (i) pelo nome dos elementos; e (ii) através da indexação. Para acessar pelo nome basta utilizar o $ como feito com data frames, note que o menu dropdown funciona aqui da mesma forma. A outra maneira de acessar elementos de uma lista á através da indexação, que neste caso devemos ter atenção a um sútil detalhe. De maneira similar as outras estruturas de dados usamos o nome_da_lista[i] para acessar o i-ésimo elemento da lista, mas também podemos acessar o mesmo elemento utilizando [[]], isso mesmo chaves duplas. &gt; x &lt;- lista[1] &gt; y &lt;- lista[[1]] Essa diferença pode parecer inofensiva de início, porém ao observar qual é a estrutura de x e de y nos revela a diferença. &gt; str(x) # List of 1 # $ nomes: chr [1:10] &quot;Mia&quot; &quot;William&quot; &quot;Gregory&quot; &quot;Amanda&quot; ... &gt; str(y) # chr [1:10] &quot;Mia&quot; &quot;William&quot; &quot;Gregory&quot; &quot;Amanda&quot; &quot;Mahmood&quot; &quot;Abigail&quot; ... Vemos que x é uma lista com o vetor nomes sendo o único elemnto e que y é o vetor nomes. Ou seja, utilizar [] (chaves simples) retorna uma lista ao passo que utilizar [[]] (chaves duplas) retorna a estrutura de dados no elemento que está sendo acessado! 3.6 resumo (melhorar nome) Para sintetizar o que foi apresentado neste capítulo a lista abaixo mostra uma ideia geral de para que são utilizadas na maior parte das vezes cada uma das estruturas de dados no R: vetor = usados salvar uma variável com elementos do mesmo tipo de dado; matriz = usadadas para armazenar mais de uma variável do mesmo tipo de dado; data frame = usados para armazenar mais de uma variável, podendo serem de tipos de dados diferentes (banco de dados); listas = usadas para salvar resultador de estimações valores retornados de função etc. Na estatística existem basicamente dois tipos de variáveis cada uma delas com dois subtipos. A primeira é chamada de variáveis qualitativas, que podem assumir valores nominais, por exemplo Nomes, ou assumir valores ordinais, por exemplo dividir peso pena, peso médio etc. O segundo tipo de variável é chamado de variáveis quantitativas, que podem ser intervalos, por exemplo a previsão do tempo quando nos traz temperatura miníma e máxima, ou assumir valore pontuais, como por exemplo a medição do pesos das pessoas↩ colocar aqui depois a seção na qual isso é discutido↩ Ressaltamos para aqueles que são familiares com outro linguagem de programação, como C, a indexação dos vetores no R começa em 1 e não em 0.↩ colocar aqui no final as seções corretas↩ Para aqueles que conhecem um pouco de computação a única desvantagem do data frame em relação a matriz é que as operação feitas com data frames são significativamente mais lentas do que quando feitas com matrizes, isso ocorre devido ao jeti de como as informações são salvas na mémoria do computador↩ "],
["importar-dados.html", "4 Importar dados para o R 4.1 Importar dados locais {importando_dados_locais} 4.2 Importando Dados da Internet {importanto_dados_da_internet}", " 4 Importar dados para o R É possível importar dados para nosso environment de duas principais maneiras, sendo a primeira imporar um arquivo que esteja salvo no computador e a segunda importar dados da internet. As subseções seguintes apresentam tais maneiras ao leitor. 4.1 Importar dados locais {importando_dados_locais} A primeira maneira é importar dados que estão salvos em nosso computador. Aqui é importante saber qual o formato do arquivo. Os formatos mais provavéis que você irá encontrar são: (i) Arquivo no formato de excel separado por vígulas (caso tenha uma planilha em arquivo excel que não no formato .csv recomendo que salve-a no formato .csv); (ii) Arquivos do software stata; (iii) Arquivos do softaware SPSS. A figura 4.1 mostra o working directory com arquivos dos três tipos e para torna-los dísponíveis em nosso enviroment basta usarmos as funções read.csv(), read.dta13() e read.spss(). Figure 4.1: Working Directory Para usar as funções relacionadas ao Stata (read.dta()) e a relacionada ao SPSS (read.spss()) são necessários os pacotes foreign e readstata13. Tendo eles basta usarmos as funções da seguinte forma: &gt; dados_csv &lt;- read.csv(&quot;dados csv.csv&quot;) &gt; &gt; dados_stata &lt;- read.dta13(&quot;dados stata.dta&quot;) &gt; &gt; dados_spss &lt;- read.spss(&quot;dados spss.sav&quot;,to.data.frame=T) Note que no arquivo do SPSS utilizamos o argumento to.data.frame = T para que os dados sejam importados como data frame, caso seja omitido os dados serão importados em forma lista. Agora pode-se obervar que os objetos foram criados e encontram-se em nosso enviroment, como a figura 4.2. Figure 4.2: Environment depois de importar dados 4.2 Importando Dados da Internet {importanto_dados_da_internet} Voltamos nossa atenção agora para como importar dados da internet para dentro do RStudio. Há mais de uma maneira de fazer isso, porém aqui será focamos na utilização de pacotes que nos permitem acessar dados do Banco Central do Brasil, Federal Reserve etc. Pacote rbcb O pacote rbcb é uma interface que liga o R ao sistema gerenciador de séries temporais do Banco Central do Brasil. Através deles podemos acessar as séries encontradas no sistema. A principal função do pacote é a get_series() que permite você importar diretamente para o environment uma série para determinado período. Para mostrar como utilizar a função vamos importar a série do percentual da carteira com atraso de 15 a 90 dias de pessoas físicas para o ano de 2017, isto é feito no chunk abaixo: &gt; library(rbcb) &gt; &gt; serie &lt;- get_series(code = 21005, start_date = &quot;2017-01-01&quot;,end_date = &quot;2017-12-31&quot;,as = &quot;data.frame&quot;) O primeiro argumento da função, code=, indica o número da série que você deseja importar. Talvez esse seja o maior impecílio do pacote, ainda é necessário acessar o Sistema de Genrenciador de Séries Temporais para obter o número da série. Neste caso o código 21005 é o referente a série “Percentual da carteira com atraso entre 15 e 90 dias - Pessoas físicas - Total”. O segundo argumento, start_date=, indica desde quando você quer buscar a série e neste caso foi escolhido janeiro de 2017, isto é, &quot;2017-01-01&quot;. O penúltimo argumento, end_date=, indica até quando você quer a série e nesse caso foi escolhido dezembro de 2017, isto é, &quot;2017-12-31&quot;. Por fim, o argumento as indica qual a estrutura de dados que desejamos importar os dados e, como pode ser facilmente deduzido, escolhemos importar os dados como um data frame. Certo, após executar essa linha de código qual o resultado você pode estar se perguntando. A figura 4.3 responde a pergunta. Figure 4.3: Usando pacote rbcb Nela vemos que há o objeto no environment e no console vemos que esse data frame nos trás a data referente ao dado e o dado em si. Pacote Quandl Outro pacote que permite importarmos dados direto da internet para o R é o Quandl. O Quandl é um site que reune diferentes fontes de dados em um local comum e o pacote permite que usando os códigos do site importemos dados de maneira similar a que fizemos com o pacote rbcb. Para começar mostramos na figura 4.4 a página referente aos dados do Federal Reserve (Banco Central dos Estados Unidos) e destacamos o código referente à taxa natural de desemprego de curto prazo da economia norte americana. Figure 4.4: Dados do FED no Quandl A função que nos permite importar os dados é a Quandl, e novamente vamos pegar os dados referentes ao ano de 2017 conforme no chunk que segue: &gt; install.packages(&quot;Quandl&quot;) &gt; library(Quandl) &gt; &gt; desemprego_eua &lt;- Quandl(code = &quot;FRED/NROUST&quot;, start_date = &quot;2017-01-01&quot;, + end_date = &quot;2017-12-31&quot;,type = &quot;raw&quot;) &gt; Os argumentos da função são bastante intuitivos, o único merecedor de uma explicação talvez seja o type=. Veremos mais para frente que quando trata-se de séries temporais há a possibilidade de armazenarmos os dados em outras estruturas de dados, de modo que os pacotes de importar dados permitem que o usuário escolha qual a estrutura de dado a ser usada. Neste cado atribuir o valor &quot;raw&quot; para o argumento type= faz com que os dados sejam salvos em um objeto na forma de um data frame, o qual estamos acostumados. colocar referencia da figura final do capitulo Pacote quantmod O último pacote que mostro é o quantmod que também nos permite pegar dados de diferentes fontes, entretanto dou enfase é que considero ser mais comum: Yahoo Finance. Suponha que queiramos obter a cotação das ações da Vale/S.A. e da Apple/S.A. na bolsa de Nova Iorque para o ano de 2017, para isso precisamos dos códigos refenrentes as ações e isso encontra-se facilmente no Yahoo Finance, como a figura 4.5 mostra. Figure 4.5: Código Vale e Apple na Bolsa de NY Agora basta utilizarmos os códigos da seguinte maneira &gt; install.packages(&quot;quantmod&quot;) &gt; library(quantmod) &gt; &gt; getSymbols(Symbols = c(&quot;VALE&quot;,&quot;AAPL&quot; ),src = &#39;yahoo&#39;,start_date=&quot;2017-01-01&quot;, + end_date=&quot;2017-12-31&quot;) &gt; Veja que no argumento Symbols= podemos atribuir um vetor com mais de um dos códigos de modo a importar mais de uma série ao mesmo tempo. Novamento o início e fimda série são definidos atrasvés dos argumentos start_date= e end_date=, respectivamente. O argumento scr= (que é uma abreviação de source) é necessário para informar de onde queremos pegar os dados. Aqui faze-se uma ressalva. Ao executar o código serão importados para o environment dois objetos com os nomes de VALE e AAPL na estrutura de xts, que é uma estrutura específica para séries temporais, porém ainda não fomos apresentados a essa estrutura de modo que iremos trasforma-las em data frames no chunk abaixo: &gt; VALE &lt;- data.frame(VALE) &gt; &gt; AAPL &lt;- data.frame(AAPL) &gt; O resultado final é apresetado na figura @ref(fig:importado_quantmod). "],
["tidy-data.html", "5 Tidy Data 5.1 Digressão: Tibbles 5.2 O que é Tidy Data 5.3 Modificando um mesmo data set", " 5 Tidy Data Neste capítulo apresentaremos o conceito de Tidy Data que nos ajuda organizar os dados com os quais os leitores irão trabalha. O modus operandi dos cursos de economia (acredito que nas demais ciências sociais não seja diferente) é de que os alunos recebam dados já no formato apropriado para o tipo de análise pedida pelo professor. Entretando, caso o leitor participe de algum projeto de pesquisa, ou até mesmo em estágios nos quais é necessário lidar com dados, eles (dados) nem sempre estarão disponíveis da maneira como precisa-se. Deste modo, saber como fazer alterações simples, porém que ajudam muito, torna o leitor mais eficiente e produtivo. Antes de apresentarmos o conceito e algumas operações básicos com dados, iremos dedicar um breve tempo para familizar o leitor com os tibbles 5.1 Digressão: Tibbles Os tibbles nada mais são do que versões modernas dos data frames. Dentra as vantagens de se usar tibbles no lugar de data frames apresentamos aqui duas delas. A primeira coisa que devemos fazer é instalar (apenas a primeira vez) e em seguida carregar o pacote tibble, para que possamos utilizar essa estrutura de dados. Para mostrar as diferenças entre tibbles e data frames vamos usar o data set cpi (de corruption perception index) que econtra-se disponível no pacote DadosLivroR, que o leitor já deve ter instalado pelo exercício 1.2. Lembre-se de que você pode utilizar ?para ver a documentação do data set. O primeiro ponto a favor dos tibbles é que ao executar determinado data set para você vê-lo no console o resultado é diferente para tibbles e data frames. Caso o data set esteja como data frame então todo o data frame será exibido no console, o que não é nemmum pouco útil para termos uma ideia dos dados. Para entender o que eu me refiro basta executar no seu RStudio o comando cpi. Entretando, caso o data frame estiver na forma de um tibble o resultado será o que aparece no chunk a abaixo &gt; cpi # # A tibble: 2,790 x 3 # Pais Ano CPI # * &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; # 1 Afghanistan 2002 NA # 2 Afghanistan 2003 NA # 3 Afghanistan 2004 NA # 4 Afghanistan 2005 25.0 # 5 Afghanistan 2006 NA # 6 Afghanistan 2007 18.0 # 7 Afghanistan 2008 15.0 # 8 Afghanistan 2009 13.0 # 9 Afghanistan 2010 14.0 # 10 Afghanistan 2011 15.2 # # ... with 2,780 more rows Percebe que ao invés de simplesmente nos retornar todos os dados, temos na verdade um “resumão” do data set com o número de observações (linhas), o número de colunas, qual a estrutura de dados de cada coluna. E além disso, nos é retornado as dez primeiras observações do data set. A segunda vantagem é que as funções que serão apresentadas ao longo deste capítulo podem apresentar comportamentos inesperados quando são usadas com data frames, coisa que não ocorre com tibbles. Para terminar nossa digressão, é interessante saber que caso o leitor queira trocar a estrutura de data frame para tibble isto é feito através da função as_tibble(nome do data frame), do pacote tibbles. Podemos agora seguir para o conceito de tidy data. 5.2 O que é Tidy Data Colocado de maneira simples e direta tidy data é uma maneira de organizar os data sets que segue três princípios básicos: Observações como linhas; Variáveis como colunas; Um tipo de unidade observacional por matrix. Os dois primeiros pontos podem ser entendidos de maneira conjunta. Para tornar o entendimento simples imagine que tenhamos um data set com a etnia e o peso de 3 pessoas da seguinte maneira: &gt; tidy_set &lt;- tibble(Nome = c(&quot;Roberto&quot;,&quot;Cecília&quot;,&quot;Sarah&quot;), + Etnia = c(&quot;Branca&quot;,&quot;Índigena&quot;,&quot;Cafuzo&quot;), + Peso = c(80,38,55)) &gt; tidy_set # # A tibble: 3 x 3 # Nome Etnia Peso # &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; # 1 Roberto Branca 80.0 # 2 Cecília Índigena 38.0 # 3 Sarah Cafuzo 55.0 Perceba que cada observação (as pessoas) encontram-se em linhas separadas e as diferentes informações sobre as pessoas estão organizadas em colunas. Parece muito óbvio isso, de fato, entretando eu não me surpreenderia caso encontra-se as mesmas informações em um data set organizado de maneira um pouco diferente… &gt; non_tidy &lt;- tibble(Nome = c(&quot;Roberto&quot;,&quot;Cecília&quot;,&quot;Sarah&quot;), + Branca = c(0,1,0), + Indigena = c(1,0,0), + Cafuza = c(0,0,1), + Peso = c(80,35,55)) &gt; non_tidy # # A tibble: 3 x 5 # Nome Branca Indigena Cafuza Peso # &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Roberto 0 1.00 0 80.0 # 2 Cecília 1.00 0 0 35.0 # 3 Sarah 0 0 1.00 55.0 Veja que agora a etnia das pessoas está espalhada em diferentes colunas. Um data set organizado desta maneira serviria para o propósito de se estimar um modelo com variável dummy. O último princípio simplesmente indica que se estamos diante de um data set sobre pessoas não faria sentido colocar as informações de uma empresa nele, tais informações devem ir para outro data set. É importante ressaltar que não há um jeito certo ou errado de se arrumar os data set, a organização das informações dentro de um data set va depender da análise que o leitor deseja fazer. Entretanto, entender o conceito de tidy data, e usá-lo como nosso ponto de partida facilita quando é necessário reorganizar o data set. 5.3 Modificando um mesmo data set Na minha (limitada) experiência percebi que a habilidade de manipular data sets não é ensinada aos alunos. Entretanto é uma atividade que é constantemente necessitada e o aluno acaba utilizando o excel e movendo as células para lá e para cá, o que por experiência próprio sei que dá muito trabalho além de as vezes não conseguimos obter o resultado que desejamos. Nesta seção mostraremos como executar manipulações elementares, porém que acredito ajudarão bastante o leitor em suas atividades. Para tornar a atividade mais interessante vamos manipular o data set cpi_raw que encontra-se disponível no pacote DadosLivroR. De maneira resumida este data_set trás o ínice de percepção de cocrrupção para 186 paises para o período de 2002 a 2016 e ele encontra-se da maneira como foi baixada do site Knoema, que através de um cadastro gratuito fornece acesso a um compilado de dados de inúmeras instituições. De modo que o além de prático o exercício demonstra a real aplicabilidade dos recursos apresentados. Além do pacote com os dados utilizaremos os pacotes: (i) tibble, (ii) dplyr,e (iii) tidyr O primeiro passo para manipularmos um data set é verificarmos como ele está organizado e definir como queremos que ele fique ao final da manipulaçao. Não há uma regra geral e isso vai variar muito de caso para caso. Abaixo vemos o data set cpi_raw. &gt; cpi_raw # # A tibble: 186 x 23 # Country `Country Name` `Country Region~ Indicator `Indicator Name` # &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; # 1 CD Congo, Democratic ~ CD KN.CSCR CPI Score # 2 CG Congo, Republic of~ CG KN.CSCR CPI Score # 3 RW Rwanda RW KN.CSCR CPI Score # 4 GH Ghana GH KN.CSCR CPI Score # 5 DZ Algeria DZ KN.CSCR CPI Score # 6 ZA South Africa ZA KN.CSCR CPI Score # 7 LY Libya LY KN.CSCR CPI Score # 8 EG Egypt EG KN.CSCR CPI Score # 9 GN Guinea GN KN.CSCR CPI Score # 10 LS Lesotho LS KN.CSCR CPI Score # # ... with 176 more rows, and 18 more variables: `Indicator # # Definition` &lt;chr&gt;, Scale &lt;chr&gt;, Units &lt;chr&gt;, `2002` &lt;dbl&gt;, # # `2003` &lt;dbl&gt;, `2004` &lt;dbl&gt;, `2005` &lt;dbl&gt;, `2006` &lt;dbl&gt;, `2007` &lt;dbl&gt;, # # `2008` &lt;dbl&gt;, `2009` &lt;dbl&gt;, `2010` &lt;dbl&gt;, `2011` &lt;dbl&gt;, `2012` &lt;dbl&gt;, # # `2013` &lt;dbl&gt;, `2014` &lt;dbl&gt;, `2015` &lt;dbl&gt;, `2016` &lt;dbl&gt; Perceba que o data_set está salvo como um tibble e que ao invés de mostrar todas as colunas, pois há muitas, é mostrado na parte de baixo quantas variáveis além das que são mostradas. Não só quantas as mais variáveis como diz o nome delas e o tipo de informação que elas contêm. Agora que vimos como está organizado o data_set, podemos definir como queremos deixar as informações organizadas. Neste caso iremos manipular o data_set e deixá-lo de acordo com os princípios do tidy data. Para tal precisamos verificar qual dos princípios precisa ser atendido, é claro que as observações (neste caso países) estão devidamente colocados em diferentes linhas e que a matriz possui apenas informações relacionadas à países. O leitor atento, porém percebeu que os anos, que são uma variável, estão espalhados em diferentes colunas. Então precisamos resolver esse problema para deixar os dados no formato que desejamos. De maneira resumida queremos como resultado final um tibble que tenha o seguinte formato: &gt; cpi # # A tibble: 2,790 x 3 # Pais Ano CPI # * &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; # 1 Afghanistan 2002 NA # 2 Afghanistan 2003 NA # 3 Afghanistan 2004 NA # 4 Afghanistan 2005 25.0 # 5 Afghanistan 2006 NA # 6 Afghanistan 2007 18.0 # 7 Afghanistan 2008 15.0 # 8 Afghanistan 2009 13.0 # 9 Afghanistan 2010 14.0 # 10 Afghanistan 2011 15.2 # # ... with 2,780 more rows Isto é, com três colunas sendo a primeira com os nomes dos países, a segundo com o ano e por fim a coluna com o valor do índice em si. Selecionando Colunas de Interessa (função select) Antes de arrumar o problema dos anos espalhados em diferentes colunas vamos selecionar apenas as colunas com as quais queremos trabalhar, ou eliminarmos as que não desejamos utilizar. Isso pode ser feito da maneira como foi mostrado no capítulo 3, acessando os elementos do tibble do mesmo jeito que o fizemos com matrizes utilizando o []. Entretando a função select()do pacote dplyr oferece uma alternativa. Queremos manter apenas a coluna com o nome dos países e as colunas dos anos, pois elas contém o índice de percepção de corrupção. A função select() precisa de dois argumentos: (i) um tibble do qual queremos selecionar as colunas, e (ii) um vetor com o nome das colunas que queremos selecionar ou com o nome das colunas que queremos eliminar. Isto é feito no chunk abaixo: &gt; cpi_tidy &lt;- select(cpi_raw,-c(Country,`Country RegionId`,Indicator, + `Indicator Name`,`Indicator Definition`, + Scale,Units)) Isso na primeira vista pode parecer mais trabalhoso do que usar os números das colunas e o operador [], porém ele deixa o script mais organizado, caso você queira rever o que executou. Outra obserção é que trabalhando com as funções do pacote dplyre tibbles os nomes das colunas não precisam estar entre aspas, entretanto caso o nome da coluna seja separa do espaço é necessário colocar o nome entre crases (` `), como no chunk. Se verificarmos como nosso novo objeto está organizado, veremos que agora temos somente as colunas que temos interesse. &gt; cpi_tidy # # A tibble: 186 x 16 # `Country Name` `2002` `2003` `2004` `2005` `2006` `2007` `2008` `2009` # &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Congo, Democra~ NA NA 20.0 21.0 20.0 19.0 17.0 19.0 # 2 Congo, Republi~ NA 22.0 23.0 23.0 22.0 21.0 19.0 19.0 # 3 Rwanda NA NA NA 31.0 25.0 28.0 30.0 33.0 # 4 Ghana 39.0 33.0 36.0 35.0 33.0 37.0 39.0 39.0 # 5 Algeria NA 26.0 27.0 28.0 31.0 30.0 32.0 28.0 # 6 South Africa 48.0 44.0 46.0 45.0 46.0 51.0 49.0 47.0 # 7 Libya NA 21.0 25.0 25.0 27.0 25.0 26.0 25.0 # 8 Egypt 34.0 33.0 32.0 34.0 33.0 29.0 28.0 28.0 # 9 Guinea NA NA NA NA 19.0 19.0 16.0 18.0 # 10 Lesotho NA NA NA 34.0 32.0 33.0 32.0 33.0 # # ... with 176 more rows, and 7 more variables: `2010` &lt;dbl&gt;, # # `2011` &lt;dbl&gt;, `2012` &lt;dbl&gt;, `2013` &lt;dbl&gt;, `2014` &lt;dbl&gt;, `2015` &lt;dbl&gt;, # # `2016` &lt;dbl&gt; Juntando colunas em uma única variável (funções gather e spread) Falta agora colocar as colunas que têm como nome os anos em uma coluna chamado de “ano” e os valores que se encontram nas colunas nomeadas com anos em uma única coluna chamada de “cpi”. Para isso usaremos a função gather() do pacote tidyr. &gt; cpi_tidy &lt;- gather(data = cpi_tidy,key = ano,value = cpi, -c(`Country Name`)) A função leva quatro argumentos. O primeiro data = recebe o nome do objeto (tibble) que faremos a manipulação. O segundo Key = recebe o nome da variável cuja os valores estão espalhados como nomes de colunas, no nosso caso a variável que está com os valores espalhados nas colunas é o “ano”, visto que as colunas estão com os nomes de 2002, 2003 e etc. O terceiro argumento recebe o nome da variável cuja os valores estão nas celulas do tibble. Por exemplo se verificarmos a sexta linha e segunda coluna do cpi_tidy veremos que o índice de percepção de corrupção da Áfrca do Sul em 2002 foi de 48, e esse valor é referente a variável “cpi”. Por fim o último argumento, que não tem nome, deve receber as colunas que queremos juntar ou as colunas que devem ser ignoradas na hora de juntar as colunas. Neste caso é mais conveniente explicitar que a coluna Country Name deve ser deixada de lado. Depois de utilizar a função gather() como especificado, temos o seguinte resultado: &gt; cpi_tidy # # A tibble: 2,790 x 3 # `Country Name` ano cpi # &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; # 1 Congo, Democratic Republic 2002 NA # 2 Congo, Republic of the 2002 NA # 3 Rwanda 2002 NA # 4 Ghana 2002 39.0 # 5 Algeria 2002 NA # 6 South Africa 2002 48.0 # 7 Libya 2002 NA # 8 Egypt 2002 34.0 # 9 Guinea 2002 NA # 10 Lesotho 2002 NA # # ... with 2,780 more rows "]
]
