[
["index.html", "Guia definitivo do R para estudantes de sociais Prefácio Motivação Organização Sobre o autor Agradecimentos", " Guia definitivo do R para estudantes de sociais Prefácio Colocar aqui o que me feze escrever o livro motivações e inspirações. Lembrar que foi dia 17/09/2017 que eu vi o vídeo que me inspirei. Motivação De maneira sucinta este livro é minha humilde tentativa de facilitar o aprendizado e utilização da linguagem R para alunos de graduação em ciências sociais, inevitavelmente, em especial economia. descrever o problema de que ao fazer trabalhos relacionados a dados (isto pe usar o excel pra guardar dados, algum software para fazer a análise copiar e colar para o word e depois se alguma coisa mudar tem que fazer toda a análise novamente) Para quem é este livro? Alunos de graduação que usam estatística para fazer trabalhos, em especial (mas não exclusivamente) para os do campo de ciências sociais. falar que esse livro é feito sob a premissa de facilitar a implementação/execução de trabalhos relacionados a análise de dados. falar que eu não pretendo ensinar a parte teórica é um livro de aplicação! Então é uma base de estatística/econometria ajuda muito a entender o livro O que você vai aprender neste livro Aprender o funcionamento do R no RStudio como linguagem de programação estatística. O que são o R e o RStudio (colocar aqui que não vou ensinar a instalar os programas pois há muito material sobre isso na internet) Mostrar os processos tradicionais de trabalhos relacionados a analise dados e mostrar como o R facilita o processo de analise dados em cada um dos processos tradicionais mostrar como juntar todas esses processos podem ser todos executados no mesmo local. que em atividades simples pode ser mais demorado fazer coisas no r, mas que com o aumento da complexidade da tarefa o r fica muito mais rapido de se fazer Organização Esta parte mostra como o livro e os capítulos estão organizados Convenções do livro descrever aqui os padrões utilizados no livro, por enquanto são: Nos chunks: &gt; indicam o código que foi executado e # resultado (output) do código executado. No texto: palavras em outros idiomas estarão em itálico, coisas que estiverem relacionamdas ao R (funções, variaveis, comandos etc) estão destacados como codigo. Os exemplos do livro trarão em si todo o código necessário para que o leitor possa reproduzi-los, salvo dito explicitamente o contrário. Vai ser comum, especialmente no começo, o leitor não entender por completo os códigos dos exemplos, mas o importante é que o leitor compreenda as partes do código referentes especificamente ao exemplo. Faço isso por dois motivos:(i) para que o leitor vá se acostumando aos poucos sem perceber com a sintaxe do R; e (ii) uma das coisas que me incomodou ao aprender é que é comum que sejam apresentados apenas pedaços de código e isso dificulta o entendimento de o que está sendo feito no geral.Será comentado todo o código apresentado para que o leitor entenda o que está sendo feito, mas com o foco sempre na parte referente ao exemplo. Pois, acredito que entendendo a “figura como um todo” é mais natutal compreender os detalhes Organização do livro Descrever aqui a lógica da organização do livro e um resumo de o que cada capítulo ensina. falar que a primeira parte busca apresentar as peças fundamentais para as outras partes, e por isso talvez seja um pouco mais chata. mas não desiste toda bonita residência começa com tijolos iguais. Organização dos capítulos Cada capítulo apresenta aspectos expositivos sobre determinado tema, além disso no final de cada capítulo há uma seção com exercícios práticos com o intuito de reinterar o que foi mostrado na parte expositiva e acrescentar coisas que não foram mostradas explicitamente na parte expositiva. Também são apresentados exemplos práticos (que podem ser reproduzidos pelo leitor) ao longo da parte expositiva. Sobre o autor Agradecimentos "],
["r-e-rStudio.html", "1 R e RStudio 1.1 O que são 1.2 Layout do RStudio 1.3 Scripts 1.4 Funcionamento do Código 1.5 Working Directory (ou pasta de trabalho) 1.6 Pacotes (ou libraries)", " 1 R e RStudio Neste capítulo vamos introduzir de maneira completa o R e o RStudio e apresentar o básico sobre seu funcionamento. De modo a facilitar o entendimento dos capítulos seguintes desta parte I do livro, que busca apresentar ferramentas sob as quais desenvolveremos nossas habilidades no R. 1.1 O que são R é uma linguagem de programação estatística baseada em comandos de linha, de modo que é dado ao usuário uma liberdade e flexilibidade na hora de fazer as análises. O RStudio é um ambiente de programação que torna mais fácil e eficiente a utilização do R. Matloff (2011) apresenta a analogia de Greg Snow para exemplificar a lógica do R. Podemos pensar no mundo de análise dados como sendo uma cidade e as possíveis análises são diferentes locais nesta nossa cidade hipotética. Os principais meios de locomoção que pensamos são transporte público (ônibus, metrô, bondinho etc.) e transporte privado (em especial carros). Analisando as possilidades sabemos que andar de ônibus é mais fácil, basta pagar a passagem saber em qual ponto subir e em qual ponto descer. Já para poder utilizar o carro há um custo de aprender a dirigir o carro, ter um conhecimento de leis, e significados de placas, ter uma espécie de mapa mental para saber onde está indo (além do financeiro hehe) e etc. Mas e afinal de contas qual é a vantagem de se utilizar o transporte privado no lugar do público? É o simples fato de ser mais confortável e possibilitar você conseguir chegar em locais que o transporte público não te levaria sem uma boa caminhada. Destaco que a analogia foi feita antes de surgir aplicativos como UBER, e na minha interpretação andar de UBER seria como pagar alguém para fazer a análise por você. O ponto é que utilizar pacotes estatíscos de botões (como SPSS, Gretl, Stata e afins) é como se você estivesse utilizando o transporte público, ao passo que ao introduzir ferramentas de programação (como o R e Python fazem, por exemplo) abre inúmeras possibilidades que são limitadas apenas pelo conhecimento do usuário. Deste modo você consegue chegar em lugares novos e chegar mais rápido em lugares que de outra maneira seria mais demorado. Dito isso, o primeiro passo para entrarmos no mundo é baixar e instalar p O eo RStudio. Para baixar o R acesse o site do R Project (https://www.r-project.org/), clique em download R e em seguida escolha um dos mirrors brasileiros, a figura 1.1 sintetizaos passos. O próximo passo é apenas executar o arquivo baixado. Figure 1.1: Baixando o R Figure 1.1: Baixando o R Já o RStudio, como dito anteriormente, é um ambiente que torna a utilização da linguagem R mais agradavél e possibilita uma organização muito boa da análise que está sendo feita. Para baixar o RStudio acesse o site do RStudio (https://www.rstudio.com/), clique no icone Download RSstudio, em seguida clique em Desktop Open Source License e por fim basta executar o arquivo baixado, a figura 1.2 sintetiza os passos. Figure 1.2: Baixando o RStudio Figure 1.2: Baixando o RStudio É importante destacar que a ordem de instalação deve ser respeitada,isto é, primeiro instalr o R e depois o RStudio. 1.2 Layout do RStudio Depois de instalar o R e RStudio abra o RStudio, pois como comentado anteriorment o RStudio é um ambiente que torna mais eficiente a programação em R, e desse modo utilizaremos ele como interface para usar o R. Ao abrir o RStudio você deve se deparar com o layout apresentado na figura 1.3. Figure 1.3: Layout do RStudio Esse layout apresenta 4 janelas principais para se usar o R no RStudio. De maneira sucinta: A janela superior esquerda é o script que, como veremos em seguida, é onde o código é escrito para ser executado; A janela superior direita, chamada de environment, e é onde encontram-se as variáveis, dados, e objetos; A janela inferior esquerda é o console onde são exibidos os resultados que não são figuras, como tabelas, regressões, contas etc; E por fim, a janela do canto inferior direito é onde são exibidos os plots produzidos. 1.3 Scripts Outra grande vantagem de se utilizar linguagens baseadas em comandos de linha são os scripts que são onde ficam armazenados os comandos que devem ser executados, no caso do R os scripts são salvos na extensão .R. Os scripts, junto com variáveis e funções, possibilitam evitar a repetição mecânica dos comandos, um exemplo trivial para ilustrar o ponto é o cálculo da índice de massa corporal (IMC), podemos calcular comuma calculadora através da fórmula \\[IMC =\\frac{peso(kg)}{altura(metros)^2}\\]. Para calcular o IMC dos membros de sua família você pode anotar o peso e altura de cada um e calcular individualmente, ou então você pode escrever o seguinte código: &gt; peso &lt;- 65 &gt; altura &lt;- 1.75 &gt; &gt; IMC &lt;- peso/altura^2 &gt; IMC # [1] 21.22449 De modo que o que você precisa fazer é apenas mudar os valores do peso altura e executar o código novamente. Dois comandos são importantes você ter em mente sobre scripts: (i) Para abrir um novo script tem se usar o atalho ctrl+shift+n; e (ii) para salvar um script baste clicar no icone de disquete que aparece na aba embaixo de untitled1 na figura 1.3. Podemos dizer que os scripts substituiem os mouse e os botões por uma tela onde o usuário através dos comandos realiza suas análises da maneira mais livre possível. 1.4 Funcionamento do Código É importante entender o funcionamento da execução do código do R. Chamamos de código o conjunto de comandos que estão salvos em um script, onde cada comando representa uma ação que pedimos para a linguagem executar. Comandos podem ser simples como calcular a média de uma vetor ou podem ser mais complexos como retornar uma mensagem caso no número seja par e outra caso o número seja impar. O chunk abaixo mostra como seriam escritos os exemplos citados anteriror mente: &gt; ## Calculando média de um vetor &gt; vetor &lt;- rnorm(10) &gt; mean(vetor) &gt; &gt; ## Vendo se um número é impar ou par &gt; x &lt;- 13 &gt; if(x %% 2 == 0){ + print(&quot;x é par&quot;) + } else { + print(&quot;x é ímpar&quot;) + } O chunk possui ao todo 4 comandos, pois as linhas que começam com # são chamadas de comentários elas são executadas apenas como texto. O primeiro comando, vetor &lt;- rnorm(10), cria um vetor com 10 números aleatório, o segundo, mean(vetor), calcula a média dos elementos do vetor, o terceiro, x &lt;- 3, atribui à variável xo valor 3 e, por fim, o quarto comando, que começa no if(x %% 2 == 0), testa de x é par e retorna uma mensagem caso ele seja par e outra caso x seja ímpar. Para executar um comando utiliza-se o atalho no teclado ctrl+Enter e a linha em que você se encontra será executada, no caso dos três primeiros comandos é direto a execução com o atalho. Porém, se prestarmos atenção o quarto comando encontra-se “espalhado” em 5 linhas e aí reside um detalhe, note que sabemos que o comando tem mais de uma linha através do + que aparece nas três linhas subsequentes à primeira. O RStudio permite que você escolha entre duas opções de execução de comandos com mais de uma linha. A primeira opção é executar uma linha de cada vez, no nosso exemplo seria necessário utilizar o ctrl+Enter quatro vezes para executar o quarto comando. A segundo opção é fazer com que comandos com mais de uma linha sejam executados de uma só vez, neste caso para executar o quarto comando seria necessário utilizar p ctrl+Enter apenas na linha if(x %% 2 ==0) para executar o quarto comando. Independente de qual das opções foi utilizada para executar o código o resultado apóes executar os quatro comandos acima é apresentado na figura 1.4 Figure 1.4: Resultado Vemos que no console aparece o comando que foi executado, linhas que começam com &gt;, seguido pelo resultado do comando, linhas que começam com [1], o que acontece nos bastidores é que ao executar um comando no script esse comando é “jogado” para o console onde ele é executado. Por fim, vemos que no Environment estão salvos o vetor e a variável x. A escolha entre as duas maneiras de executar o código é uma escolha do usuário, pois o resultado final do código será o mesmo. Para optar pela execução de todas as linhas do comando de uma só vez acesse a aba \\(Tools\\Rightarrow Global\\ Options\\Rightarrow Code\\) e então marque a opção Execute all lines in a statement1, a figura 1.5 mostra o caminho completo. Figure 1.5: Opções de execução do código RStudio Um último detalhe para ae comentar sobre a execução dos códigos é que em boa parte dos comandos a execução do código é quase que instantanea, porém há situações em que o computador pode demorar para executar o código. Nessas situações é importante que você não execute nenhum outro comando enquanto o R não terminou de executar o comando anterior. Enquanto o R está executando um commando aparece uma “placa” no canto superior direito do console escrito stop, destacado na figura 1.6. Ao terminar de executar o código essa “placa” sumirá. Um exemplo de comando tende a demorar (relativamente) a ser executado é a estimação dos modelos de controle sintético apresentados por Abadie, Diamond, and Hainmueller (2010). Passamos agora a discussão para entender onde o R “vive”, isto é, qual a maneira como o R interaje com o computador, no sentido de buscar arquivos para serem trabalhados dentro do R ou salvar resultados que foram obtidos no R. 1.5 Working Directory (ou pasta de trabalho) O jeito mais comum de se organizar um trabalho que envolva análise dados (seja projeto de pesquisa, trabalho da universidade etc.) é através de pastas no computador. É comum que os dados que serão analisados tenham de ser importados para dentro do R (colocar aqui referencia da seção), ou então que você queira salvar um plot que foi gerado dentro do R, o working directory nada mais é do que a pasta no seu computador onde o R vai buscar os arquivos para serem importados e salvar os resultados que serão exportados. Há duas funções que você precisa conhecer no que tange à pasta de trabalho. A primeira é para definir a pasta de trabalho e chama-se setwd(), onde wd é abreviação de working directory o único argumento que essa função leva é o caminho da pasta entre aspas, como o exemplo abaixo: &gt; setwd(&quot;C:/Users/Vinicius/Desktop/working directory&quot;) É importante notar que as barras são inclinadas para a direita e que o endereço começa no disco em que se encontra a página, pode parecer bobeiras, mas são erros comuns nos primeiros contato com o R. Para copiar o endereço de uma pasta basta clicar com o botão direito e selecionar a opção copiar, como se fosse qualquer outro arquivo, e depois colar denteo da função setwd(). A segunda função importante para se saber é a getwd(), você consegue adivinhar o que ela faz? Isso mesmo, a função mostra para você qual é a pasta na qual o R está “vivendo” atualmente e ela não possui nenhum argumento. Por exemplo, este livro foi escrito dentro do RStudio e no momento o working directory é a pasta: &gt; getwd() # [1] &quot;C:/Users/Vinicius/Dropbox/projects/livro_r&quot; Na seção (colocar aqui seção de boas praticas script) iremos discutir boas práticas em relação ao script e working directory, mas vale a pena destacar adiantar uma boa prática. Como dito anteriormente é comum organizarmos nossos trabalhos acadêmicas em pastas, então suponhamos que estejamos fazendo um trabalho de econometria sobre o clássico exemplo de renda e consumo, estou assumindo que no nosso computador há uma pasta onde encontram-se os dados que o professor passou (ou você obteve), possíveis arquivos de texto e etc. É uma boa prática você criar dentro dessa pasta uma outra pasta e usá-la como working directory. 1.6 Pacotes (ou libraries) Em todas as esferas da análise de dados (importar dados, manipular dados, estimar modelos/testes estatísticos e reportar resultados) no R trabalha-se com funções que nos auxiliam, setwd() e mean() são duas funções já apresentadas. O R possui várias funções built in, isto é, que ao instalar o programa as funções já estão disponíveis. Um pacote neste contexto nada mais é do que um conjunto de funções sobre um tema parecido que não são carregadas autimaticamento ao abrir o RStudio. Por exemplo, no capítulo @ref(intrpducao_ao_ggplott2) vamos mostrar o básico do pacote ggplot2 que é um pacote desenvolvido para viasualização de dados e contém funções para histogramas, boxplots, gráficos de densidade 2d etc. Para instalar um novo pacote utiliza-se a função install.packages(&quot;nome do pacote&quot;), isso instala no seu computador as funções que estão no pacote, mas não as deixa disponíveis para utilização. Para fazer isso é necessário que você carrege as funções para o R através do comando library(nome do pacote). Ao instalar um pacote uma aba com o progresso abrirá mostrando qual o status da instalação, como mostrado na figura 1.6. Figure 1.6: Status de instalação de pacote Duas observações: (i) note que ao instalar o pacote o nome do pacote deve estar entre aspas e ao carregar o nome do pacote está sem aspas; (ii) **só é necessário instalar o pacote uma vez no seu computador (a primeira vez que você for utilizá-lo), mas é necessário que você carrege o pacote sempre que vocÊ abrir o R. Exercise 1.1 (Instalar o pacote tidyverse) O pacote tidyverse será muito utilizado ao longo do livro e das suas atividades dentro do R. Esse pacote é na verdade um conjunto de pacotes que modernizaram e deixaram de maneia mais natural fazer as atividades relacionadas à analise de dados no R. Isto é, ele tem funções de manipulação de dados, visualização, estimação, programação etc. Seu exercício é instalar corretamente esse pacote. Pacotes do GitHub Para fins deste livro podemos descrever o GitHub como uma “nuvem” (do mesmo jeito que o google drive, icloud etc.), mas para códigos de programação2. Desse modo é possível que pacotes para o R sejam criando e colocados a disposição para os usuários no GitHub. E neste caso a instalação do pacote é um pouco diferente. Para instalar um pacoite que encontra-se no GitHub utiliza-se a função install_github(&quot;usuario/pacote&quot;). onde usuário é o nome do usuário que fez o pacote no GitHub e pacote é o nome do pacote. Entretando a função install_github pertence ao pacote devtools. Ou seja, para instalar um pacote do GitHub você deve ter instalado no computador o pacote devtools, que é instalado como mostrado em 1.6. Exercise 1.2 (Pacote com dados usados no livro) Os dados que serão utilizados nos exercícios e exemplos do livro estão disníveis em um pacote que encontra-se no GitHub, deste modo seu exercício agora é instalar e carreare o pacote devtools para poder ter acesso a função install_github. Em seguida baixe o pacote “DadosLivroR” do usuário “vinisousa04” com a função install_github. References "],
["primeiros-comandos-no-R.html", "2 Primeiros Comandos no R 2.1 R como calculadora 2.2 Workspace/Environment", " 2 Primeiros Comandos no R Agora que apresentamos o R e RStudio e o básico sobre seu funcionamento, vamos começar nossa aventura dentro das linhas de comando do R apresentando… Neste capitulo usaremos os os pacotes &gt; library(tidyverse) # Loading tidyverse: ggplot2 # Loading tidyverse: tibble # Loading tidyverse: tidyr # Loading tidyverse: readr # Loading tidyverse: purrr # Loading tidyverse: dplyr # Conflicts with tidy packages ---------------------------------------------- # filter(): dplyr, stats # lag(): dplyr, stats &gt; library(DadosLivroR) 2.1 R como calculadora A utilização mais trivial que se pode fazer do R é como uma calculadora. Onde podemos fazer operações “comuns”, como soma, multiplicação, exponenciação e etc. A execução das operações comuns é muito intuitiva, se quisermos somar números utilizamos o símbolo +, dividir usamos /, exponenciação usamos ^. Porém há outros tipos de operações3 que podemos fazer que isoladamente são simples, mas que são muito úteis no processo de análise de dados. O primeiro tipo é o que chamamos de testes de igualdade. São operações que testam se duas variáveis são iguais, se uma é menor ou maior que a outra. Diferente das operações comuns que retornam valores númericos, essa operações retornam valores lógicos de TRUE para verdadeiro e FALSE para falso, valores lógicos são apresentados devidamente na seção @ref(tipos_de_dados). Então ao executar o comando 2 == 3 o resultado exibido será FALSE e ao executar o comando 2 &lt;= 3 retornará um resultado TRUE, pois é claro que 2 não é igual a 3 e é menor que 3. Como pode se verificar abaixo &gt; 2==3 # [1] FALSE &gt; 2&lt;=3 # [1] TRUE Isso pode parecer bobo, mas toda a estatística que tradicionalmente se aprende em um curso de graduação4 é baseado em testes de hipótese que em termos práticos é verificar se o p valor de uma estatística é menor do que \\(1-nível\\ de\\ significância\\ escolhido\\)5. Ou seja, podemos automatizar decisões através de testes de igualdade. O outro tipo de operação é chamada de connectivos/operadores lógicos. Da mesma maneira que os testes de igualdade os operadores lógicos retornam valores TRUEou FALSE. Há três operadores importantissímos, são eles o E que retorna TRUE caso as duas condições sejam verdadeiras e FALSE caso contrário. O OU que retorna TRUE caso uma das duas condições seja verdadeira e FALSE caso contrário. E o negação que retorna TRUE caso a condição seja falsa e FALSE caso a condição seja verdadeira. É importante parar um pouco e refletir sobre o que isso significa para ter certeza que você entendeu, e para ajudá-lo a compreendeer e mostrar os símbolos dos operados no R vamos analisar um exemplo detalhado. A tabela 2.1 traz resumidamente os principais operadores do R. Table 2.1: Principais Operadores do R Operação Descrição Resultado x + y Soma y ao x Número x - y Subtrai y de x Número x * y Multiplica x, y vezes Número x / y Divide x por y Número x ^ y Eleva x à y potência Número x == y Testa se y é igual a x TRUE/FALSE x &lt;= y Testa se y é menor ou igual a x TRUE/FALSE x &gt;= y Testa de y é maior ou igual a x TRUE/FALSE x &amp; y Operador lógico ‘E’ TRUE/FALSE x | y Operador lógico ‘OU’ TRUE/FALSE !x Operador lógico de negação TRUE/FALSE (#exm:operador-logico ) (Utilização dos operadores de teste e lógicos) O principal objetivo deste exemplo é mostrar uma aplicação de como os operadores de teste e lógicos são usados no precessso dentro do R para facilitar o processo de análise de dados. A motivação do exemplo será mostrar comparar a percepção da corrupção na América Latina e Caribe com a percepção de corrupção na África Subsahariana. Espeficicamente vamos usar o índice de percepção de corrupção para os anos de 2006 a 2015, sem os anos de 2007 e 2009 para verificar se a percepção de corrupção na América latina é maior ou menor do que na África e verificar se há algum comportamente em comum ao longo do tempo nas médias de percepção de corrupção. O índice de percepção de corrupção varia entre 0 e 100 e quanto mais próximo de 100 menor é a percepção de corrupção. O exemplo pode ser desmontado nos seguintes passos: (i) carregar pacotes; (ii) Selecionar dados; (iii) Filtrar os dados; (iv) Criar variaveis que queremos; e (v) Ver os resultados Vamos carregar os pacotes que usaremos: &gt; library(tidyverse) &gt; library(DadosLivroR) Agora vamos selecionar o data set chamada data_set1 do pacote DadosLivroR e visualizar o início dele. Para obter uma descrição do data set digite ?data_set1 no console. Ainda não apresentamos a função &lt;-, mas a grosso modo sempre que você se deparar com x &lt;- 2 leia como “x recebe 2”, onde vamos chamar o que estiver o lado esquerdo do &lt;- de “objeto daqui para frente. No caso do chunk abaixo seria”dados recebe data_set1“, desse modo você pode usar o data_set1 sempre que precisar chamando o objeto dados. &gt; # pegando os dados &gt; dados &lt;- data_set1 &gt; &gt; head(dados) # # A tibble: 6 x 9 # Pais Regiao Ano PerCap_dolar PerCap_growth Inflacao # &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; # 1 Afghanistan South Asia 2006 397.9859 2.200613 7.2548956 # 2 Afghanistan South Asia 2008 444.9501 1.040489 30.5549406 # 3 Afghanistan South Asia 2010 553.3003 5.425968 0.8925369 # 4 Afghanistan South Asia 2011 569.2334 2.879648 10.2016601 # 5 Afghanistan South Asia 2012 630.4274 10.750252 7.2182578 # 6 Afghanistan South Asia 2013 621.8181 -1.365634 7.6543166 # # ... with 3 more variables: CPI &lt;dbl&gt;, PFI &lt;dbl&gt;, DI &lt;dbl&gt; Em seguida vamos filtrar os dados e selecionar as variaveis que iremos trabalhar. Vamos selecionar as regiões da américa latina e África subsahariana e as variaveis relacionadas à região, ao ano e CPI que é índice de percepção de corrupção. O código abaixo faz isso: &gt; filtrado &lt;- dados %&gt;% + filter(Regiao == &quot;Latin America &amp; Caribbean&quot; | Regiao == &quot;Sub-Saharan Africa&quot;) %&gt;% + select(Regiao, Ano, CPI) Onde tiver %&gt;% leia “então”. Deste modo o chunk acima está fazendo o seguite: pegando o objeto dados, então filtrando a coluna Regiao para valores que sejam iguais à “Latin America &amp; Caribbean” OU iguais à “Sub-Saharan Africa”, então selecionando as colunas com o nome de Regiao, Ano e CPI e salvando o resultado em um objeto chamado filtrado. Veja que aqui utilizamos o operador lógico OU para fazer o filtro, filter(Regiao == &quot;Latin America &amp; Caribbean&quot; | Regiao == &quot;Sub-Saharan Africa&quot;)! Antes de prosseguirmos, vamos verificar o data frame filtrado: &gt; filtrado # # A tibble: 496 x 3 # Regiao Ano CPI # &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; # 1 Sub-Saharan Africa 2006 22.00000 # 2 Sub-Saharan Africa 2008 19.00000 # 3 Sub-Saharan Africa 2010 19.00000 # 4 Sub-Saharan Africa 2011 20.05035 # 5 Sub-Saharan Africa 2012 22.00000 # 6 Sub-Saharan Africa 2013 23.00000 # 7 Sub-Saharan Africa 2014 19.00000 # 8 Sub-Saharan Africa 2015 15.00000 # 9 Latin America &amp; Caribbean 2006 29.00000 # 10 Latin America &amp; Caribbean 2008 29.00000 # # ... with 486 more rows Vemos que temos o que queremos. Agora basta calcularmos as médias de cada ano para cada uma das regiões e depois a média geral de cada grupo: &gt; resultado &lt;- filtrado %&gt;% + group_by(Ano, Regiao) %&gt;% # agrupando por Ano e Regiao + summarise(media_ano = mean(CPI,na.rm = T)) %&gt;% # Calculando media + group_by(Regiao) %&gt;% # Agrupando por regiao + mutate(media_periodo = mean(media_ano), # criando media por ano + `menor que periodo` = if_else(media_ano &lt;= media_periodo, &quot;sim&quot;, &quot;Não&quot;)) Que resulta no seguinte: Ano Regiao media_ano media_periodo menor que periodo 2006 Latin America &amp; Caribbean 33.20833 35.59501 sim 2006 Sub-Saharan Africa 28.31429 30.70347 sim 2008 Latin America &amp; Caribbean 34.45833 35.59501 sim 2008 Sub-Saharan Africa 28.57895 30.70347 sim 2010 Latin America &amp; Caribbean 34.52174 35.59501 sim 2010 Sub-Saharan Africa 28.42105 30.70347 sim 2011 Latin America &amp; Caribbean 33.44666 35.59501 sim 2011 Sub-Saharan Africa 29.01819 30.70347 sim 2012 Latin America &amp; Caribbean 37.54167 35.59501 Não 2012 Sub-Saharan Africa 33.21053 30.70347 Não 2013 Latin America &amp; Caribbean 36.79167 35.59501 Não 2013 Sub-Saharan Africa 32.44737 30.70347 Não 2014 Latin America &amp; Caribbean 37.58333 35.59501 Não 2014 Sub-Saharan Africa 33.05405 30.70347 Não 2015 Latin America &amp; Caribbean 37.20833 35.59501 Não 2015 Sub-Saharan Africa 32.58333 30.70347 Não Neste último chunk pegamos o objeto filtrado, então agrupamos por Ano e Regiao, então calculamos a média do CPI (índice de percepção de corrupção), então agrupamos por Regiao, então adicionames duas variáveis: (i) media_periodo que tem a média do CPI para todo o período de cada região; e (ii) menor do que período que diz se a média no ano específico é menor ou não do que a média geral. E perceba que na última linha usamos o teste de igualdade para computar o valor da última variável,if_else(media_ano &lt;= media_periodo, &quot;sim&quot;, &quot;Não&quot;), o que essa linha fez comparar linha por linha se o valor da coluna “media_ano” é menor que o o valor “media_periodo” e caso o valor fosse menor então a coluna “menor que periodo” recebia o valor “sim” na respectiva linha, caso não fosse recebia o valor “não”! Não se preocupe em entender os detalhes do código, pois cada uma das ferramentas utilizadas serão propriamente apresentadas no decorrer do livro. O importante é que tenha ficado claro como os operados de teste e lógicos são utilizados. Outra coisa, pode parecer que é muito código, em um script seria apenas algo do tipo: &gt; library(DadosLivroR) &gt; library(tidyverse) &gt; &gt; # Pegar dados &gt; &gt; dados &lt;- data_set1 &gt; &gt; resultado &lt;- dados %&gt;% + filter(Regiao == &quot;Latin America &amp; Caribbean&quot; | Regiao == &quot;Sub-Saharan Africa&quot;) %&gt;% + select(Regiao, Ano, CPI) %&gt;% + group_by(Ano, Regiao) %&gt;% + summarise(media_ano = mean(CPI,na.rm = T)) %&gt;% + group_by(Regiao) %&gt;% + mutate(media_periodo = mean(media_ano), + `menor quegeral` = if_else(media_ano &lt;= media_periodo, &quot;sim&quot;, &quot;Não&quot;)) Vamos agora apresentar para o usuário como acessar os dados e variáveis que o leitor importa para o R. 2.2 Workspace/Environment Para entendermos o que é o Workspace/Environment vamos antes apresentar oficialmente o operador de atribuição -&gt;. A utilizaçãp desse operador da-se da seguinte maneira nome -&gt; objeto, onde nome é nome do objeto6 que você quer salvar. Se olharmos o exemplo ?? vemos que utilizamos o operador de atribuição três vezes para salvar os objetos dados, filtrado e resultado, ou seja nesse caso nossos objetos são data sets, mas poderiam ser várias outras coisas, como vetores, resultados de regressão, gráfico e etc. Se olharmos o Workspace/Environment depois de executar o código do exemplo teremos algo como mostra a 2.1. Figure 2.1: Exemplo de workspace/Environment Veja que temos nossos três objetos disponíveis para quando quisermos utiliza-los. Estamos chamando de operações pois é uma maneira mais direta de se entender, sob uma perspectiva formal matemática seria incorreto utilizar essa nomeclatura↩ Estatística inferentista↩ Colocar aqui explicação sobre o significado do alpha e intervalo de confiança em termos dos tipos de erro I e II↩ Ressaltamos aqui que o termo objeto não tem a mesma conotação que teria no caso de liguagens orientadas a objetos↩ "],
["estruturas-de-dados.html", "3 Estruturas de Dados 3.1 Tipos de dados 3.2 Vetores 3.3 Matrizes 3.4 Data Frames 3.5 Listas 3.6 resumo (melhorar nome)", " 3 Estruturas de Dados Neste capítulo vamos apresentar ao leitor os tipos de dados e estruturas de dados fundamentais do R. Nota-se que não são apresentados todos os tipos e estruturas de dados, entretanto garantimos que os aqui apresentados serão o suficiente para resolver quase todos (se não todos) os problemas e aplicações que o leitor se deparar com. Também ressalvamos que talvez esse capítulo seja o mais importante desta parte do livro, pois um bom entendimento sobre os tipos de informações e como elas são armazenadas (dentro do R) é essencial para o desenvolvimento de habilidades para lidar com dados. Ressaltamos que o objetivo deste capítulo é fazer com o que leitor saiba “quais são e como são”&quot; as estruturas de dados, pois as ferramentas de “como trabalhar” com as estruturas de dados serão apresentadas ao longo do livro. Sem mais delongas os tipo de dados são como uma determinada informação pode ser registrada e já as estruturas de dados são como as informações são armazenadas de modo que possam ser utilizadas, um pouco abstrata essa explicação até agora não acham? Bem, uma analogia que pode ajudar a compreender a diferença entre tipos de dados e estruturas de dados é a seguinte: Acredito que seja familiar a todos o final do filme Toy Story (o primeiro da trilogia), quando o Woody e o Buzz perdem o caminhão da mudança contratado pela Mãe do Andy (digo mãe e não família pois o Pai do Andy é um mistério). Bem se recordarmos bem alguns brinquedos o Andy trouxe com ele dentro do carro (em especial teria trazido o Woody e o Buzz) e ao mesmo tempo outro brinquedos estavam sendo transportados no caminhão. Onde eu quero chegar com isso? Os brinquedos seriam um tipo de informação (no caso de uma mudança poderíamos pensar que as roupas seriam outro tipo de informação) e o caminhão da transportadora e o carro da mão do Andy seriam as diferentes estruturas nas quais é possível carregar os dados. Com a diferença entre tipos e estruturas de dados explicada vamos agora apresentar ao leitor explicitamente o funcionamento de tais coisas no R. Começamos apresentando os tipos de dados e em seguida as estrutura. 3.1 Tipos de dados Para apresentar os diferentes tipos de como as informações podem ser armazenadas vamos utilizar uma base fictícia de empregados apresentada na tabela 3.1. Nela temos 6 colunas representando diferentes variáveis. Table 3.1: Empregados Nome Tempo_emprego Setor Peso Nascimento Casado Bandar 1 Financeiro 41.76 1999-09-25 TRUE Devin 2 Estrutura 40.87 1999-02-02 TRUE Nizhoni 3 Estrutura 39.59 1999-06-18 TRUE Henna 4 Marketing 36.35 1999-11-28 TRUE Adrian Christopher 5 Marketing 44.33 1999-01-22 FALSE Jazzmin 6 Marketing 35.40 1999-03-06 TRUE Noah 7 Estrutura 42.53 1999-12-21 FALSE Zong 8 Marketing 40.70 1999-05-31 FALSE James 9 Estrutura 40.51 1999-06-22 TRUE Jesse 10 Estrutura 37.28 1999-03-30 FALSE Cada coluna possui um tipo diferente de informação e cada informação é armazenada de um jeito diferente. A lista abaixo sintetiza os tipos de dados e a coluna da tabela com a qual ela está relacionada7. Character (ou string): São caracteres textuais que podem assumir qualquer valor. Na tabela é a coluna relaciona ao Nome. Os elementos dos vetores de caracteres devem estar entre aspas &quot;elemento&quot;; Integer: São números inteiros, neste caso relacionado com a coluna idade; Double: São números decimais, neste caso relacionado à coluna de peso; Factor: São caracteres textuais mais podem assumir somente um determinado tipo de valor. Neste caso seria a coluna que traz o setor no qual o empregado trabalha. Outro exemplo de factor seria o tipo sanguíneo em um banco de dados de pacientes; Dates: São valores textuais que são interpretados como datas, neste caso relacionado à coluna nascimento; Logical: Assumem o valor TRUE ou FALSE, também chamados de valores booleanos. A função str() permite verificar a estrutura dos nossos objetos, o chunk abaixo mostra a utilização da função na nossa base de dados de empregados &gt; str(empregados) # &#39;data.frame&#39;: 10 obs. of 6 variables: # $ Nome : chr &quot;Bandar&quot; &quot;Devin&quot; &quot;Nizhoni&quot; &quot;Henna&quot; ... # $ Tempo_emprego: int 1 2 3 4 5 6 7 8 9 10 # $ Setor : Factor w/ 3 levels &quot;Estrutura&quot;,&quot;Financeiro&quot;,..: 2 1 1 3 3 3 1 3 1 1 # $ Peso : num 41.8 40.9 39.6 36.4 44.3 ... # $ Nascimento : Date, format: &quot;1999-09-25&quot; &quot;1999-02-02&quot; ... # $ Casado : logi TRUE TRUE TRUE TRUE FALSE TRUE ... Seguindo na nossa analogia da mudança as estruturas de dados seriam os meios através dos quais podemos transportar os objetos de uma casa para outro, como carros, caminhões etc. Deste modo, nesta seção vamos apresenta ao leitor o que são e exemplos de como construir: (i) Vetores, (ii) Matrizes, (iii) Data frames e (iv) Listas 3.2 Vetores É a estrutura mais básica (e fundamental) do R. De maneira objetiva um vetor é uma sequência de elementos do mesmo tipo. Agora vamos introduzir aqui 4 aspectos importantes sobre vetores. Criando Vetores Há diversas maneiras de se criar vetores e a sua imaginação é de fato o limite, porém há jeitos mais triviais que são muito utilizados. Dois destes triviais são através da função concatenar, c(), e a função sequência, seq(). O chunk abaixo ilustra maneiras diferentes de se criar a sequência 1, 2, 3, 4, 5, 6, 7, 8, 9, 10. &gt; c(1,2,3,4,5,6,7,8,9,10) # [1] 1 2 3 4 5 6 7 8 9 10 &gt; c(1:10) # [1] 1 2 3 4 5 6 7 8 9 10 &gt; seq(from = 1, to = 10, by=1) # [1] 1 2 3 4 5 6 7 8 9 10 &gt; seq(from = 1, length.out = 10,by = 1) # [1] 1 2 3 4 5 6 7 8 9 10 Quando quisermos salvar um determinado vetor em um objeto x, basta utilizarmos o operador de atribuição &lt;- da seguinte maneira x &lt;- c(1:10). A lógica é a mesma para criar vetores com outros tipos de dados, como por exemplo criar um vetor contendo as primeiras letras do alfabeto e outro com os primeiros dias de 2017. &gt; letras &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;) &gt; letras # [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &gt; dias &lt;- seq(from = as.Date(&quot;01/01/2017&quot;,format=&quot;%d/%m/%Y&quot;),length.out = 5,by = &quot;day&quot;) &gt; dias # [1] &quot;2017-01-01&quot; &quot;2017-01-02&quot; &quot;2017-01-03&quot; &quot;2017-01-04&quot; &quot;2017-01-05&quot; Não se preocupe caso não tenha ficado claro a sintaxe do vetor dias, mais para frente vamos discutir em maior detalhe datas8 Acessando elementos Acessar elementos específicos de vetores é algo muito útil (acreditem no que eu digo) e fácil, basta utilizar x[i], onde x é um vetor e i o i-ésimo elemento9. No chunk abaixo segue mostro alguns exemplos de como acessar elementos dos vetores &gt; x &lt;- c(1:10) # criando um vetor x &gt; x[7:9] # pegando elementos de 7 a 9 # [1] 7 8 9 &gt; x[length(x)] &lt;- 0 # substituindo o último elemento por 0 &gt; y &lt;- x[1:4] A última linha do chunk acima crian um novo vetor y com os 4 primeiros valores do vetor x, ou seja, mais um jeito de se criar vetores. Mais adiante no livro10 mostraremos que os filtros utilizados nos dados (como por exemplo selecionar de um banco de dados apenas os pacientes com pressão arterial acima de 140 X 90 mmHg) nada mais é do que acessar elementos do vetores que satisfaçam de terminadas condições. Operações Vetorizadas Dizer que as operações são vetorizadas é apenas dizer que ao aplicar uma funções em um vetor essa função será aplicada em cada um dos elementos do vetor. Daí inclusive a importância de internamente o R não aceitar vetores com tipos de informação diferentes, pois não faria sentido, por exemplo, efetuar a multiplicação em um vetor que contem letras!! A ideia é bastante simples e intuitiva, porém não custa nada visualizar alguns exemplos. &gt; a &lt;- c(1,4,9,16,25,36,49,64,81) &gt; sqrt(a) # sqrt é a raiz quadrada # [1] 1 2 3 4 5 6 7 8 9 &gt; a+1 # [1] 2 5 10 17 26 37 50 65 82 Perceba que cada vez que uma função é aplicada no vetor ela na verdade é aplicada em cada elemento que compõe o vetor. O último aspecto importante para se introduzir sobre vetores é a reciclagem. Reciglagem O que você imagina que acontece quando a operação c(1,2)+c(1,1,1,1) é efetuada? O nome da subseção já da uma boa dica. O que acontece é que o vetor de menor comprimento é reciclado, isto é, reutilizado, para que a operação seja efetuada e resultando no seguinte vetor c(2,3,2,3). Importante salientar que isso ocorre quando comprimento do maior vetor é múltiplo do comprimento do vetor menor, caso não seja este caso será retornado um erro. O chunk abaixo explicita essas duas situações &gt; c(1,1)+c(1,2,1,2) # [1] 2 3 2 3 &gt; c(1,1)+c(1,2,1,2,1) # Warning in c(1, 1) + c(1, 2, 1, 2, 1): longer object length is not a # multiple of shorter object length # [1] 2 3 2 3 2 3.3 Matrizes A segunda estutura apresentada é a matriz, que nada mais é do que uma extensão do vetor para uma dimensão a mais. Colocando de outro jeito uma matriz é uma estrutura com colunas com o mesmo número de linhas e que armazenam o mesmo tipo de informação. O leitor provavelmente já se deparou em algum momento da vida com uma matriz do seguinte formato &gt; matrix(data = letters[1:6],ncol=3) # [,1] [,2] [,3] # [1,] &quot;a&quot; &quot;c&quot; &quot;e&quot; # [2,] &quot;b&quot; &quot;d&quot; &quot;f&quot; Assim como foi feito com vetores, vamos mostrar como criar matrizes do zero, como acessar seu elementos e por fim como discutiremos a título de informação, não se preocupem, sobre operações matemática com matrizes. Criando Matrizes Para criar matriz utilize a função de nome matrix(), que surpresa, na qual são necessários no mínimo dois argumentos. O argumento data para o qual deve ser passado um vetor que irá popular a matriz e o segundo argumento necessário é ou ncolou nrow, especificando claramente o número de colunas ou o número de linhas. Perceba que é importante que o vetor passado para data tenha um comprimento compátivel com o número de linhas ou número de colunas. Abaixo tem o exemplo de como criar uma matriz &gt; matriz_simples &lt;- matrix(data = c(1:25),nrow = 5,byrow = TRUE) &gt; matriz_simples # [,1] [,2] [,3] [,4] [,5] # [1,] 1 2 3 4 5 # [2,] 6 7 8 9 10 # [3,] 11 12 13 14 15 # [4,] 16 17 18 19 20 # [5,] 21 22 23 24 25 O terceiro argumento byrow recebe um valor lógico, e tem como default FALSE e como o nome diz ele indica se a matriz deve ser preenchida por linhas, byrow=TRUE ou por colunas. Perceba que na primeira matriz apresentada nesta seção não tem o esse argumento e por consequência a matriz foi preenchida por colunas. Acessando Elementos Como a matriz é uma extensão dos vetores a ideia é a mesma, com a única diferença que é necessário diferenciar o indexador de linha e de coluna. E isso é feito de maneira muito simples e direta com o operador [], da seguinte maneira: matriz[i,j] onde i denota as linhas e j denota as colunas. Caso quiséssemos pegar somente os elementos das duas primeiras linhas e das duas últimas colunas da matriz_simples uma maneira seria &gt; matriz_simples[-c(3:5),c(4,5)] # [,1] [,2] # [1,] 4 5 # [2,] 9 10 Note que usamos -c(3:5) para indicar que queremos todas as linhas menos as linhas 3, 4, 5. O mesmo poderia ter sido feito para as colunas. Vale destacar uma sutileza importante para compreender a utilização de matrizes no R. Pode haver casos em que desejamos acessar apenas uma coluna (ou linha) específica de uma determinada matriz e acredito que a tentativa mais natural para todos seria algo como matriz_simples[,3], mas ao executar esse comando no console teríamos como resultado &gt; matriz_simples[,3] # [1] 3 8 13 18 23 Um vetor! E neste caso teríamos que nos perguntar: Queremos que o resultado da nossa operação (selecionar uma ou coluna especifica) seja um vetor ou uma matriz coluna (ou linha)? Caso a resposta seja um vetor deve ser executado o comando como acima, porém caso não seja esse o caso adicionamos o argumento drop=FALSE fazendo com que a estrutura de matriz seja preservada. &gt; matriz_simples[,3, drop = F] # [,1] # [1,] 3 # [2,] 8 # [3,] 13 # [4,] 18 # [5,] 23 Por fim, note que o resultado de não selecionar nenhuma coluna é selecionar todas as colunas, e o mesmo se aplica para colunas. E neste caso as operações que efetuarmos nas matrizes coluna ou linha serão automaticamente vetorizadas. Operações com matrizes Vamos aqui mostrar a título de informação algumas operações matemáticas com matrizes. Digo a título de informação, pois constatei na minha experiência que a utilização dessas operações é rara, porém acredito que seja importante saber da existência. Antes de mostarmos os procedimentos vamos criar duas matrizes para trabalharmos com elas, vamos criativamente chama-las matrix_1 e matrix_2. &gt; matrix_1 &lt;- matrix(data = 1:6,ncol = 3) &gt; matrix_2 &lt;- matrix(data = 1:6, ncol = 2) Multiplicação e Soma De maneira geral podemos nos deparar com dois casos: (i) queremos somar/multiplicar um número com/por uma matriz ou (ii) queremos multiplicar duas matrizes. Quando nos encontramos no primeiro (somar/multiplicar um número por um matriz) caso basta usar os operadores apresentados na seção colocar aqui a referencia para a seção R como calculadora e a operação é aplicada em cada elemento da matrix, como feito no chunk que segue &gt; 3+matrix_1 # [,1] [,2] [,3] # [1,] 4 6 8 # [2,] 5 7 9 &gt; 3*matrix_2 # [,1] [,2] # [1,] 3 12 # [2,] 6 15 # [3,] 9 18 &gt; sqrt(matrix_1) # [,1] [,2] [,3] # [1,] 1.000000 1.732051 2.236068 # [2,] 1.414214 2.000000 2.449490 Já no segundo caso (multiplicar matrizes) temos que colocar o operador * entre %s para que o R entenda que queremos efetuar operações matriciais &gt; matrix_1 %*% matrix_2 # [,1] [,2] # [1,] 22 49 # [2,] 28 64 É claro que as matrizes devem ter dimensões vpalidas para que a multiplicação seja efetuada. Determinante, Transposta e Inversa Brevemente vamos apresentar as funções para obtermos o determinante, a transposta e a inversa de uma matriz. Começamos com o determinante que é calculado através da função det(): &gt; matriz &lt;- matrix(c(1:4),ncol=2,byrow = T) &gt; det(matriz) # [1] -2 A transposta por sua vez é calculada através da função t(): &gt; t(matriz) # [,1] [,2] # [1,] 1 3 # [2,] 2 4 E por fim a inversa é obtida através da função solve(): &gt; solve(matriz) # [,1] [,2] # [1,] -2.0 1.0 # [2,] 1.5 -0.5 Passamos agora para a estrutura chamda de data frame, que funciona com os principios de vetores e matrizes, porém com algumas modificações que a tornam muito útil na prática. 3.4 Data Frames Os data frames possuem a mesma estrutura que uma matriz, isto é, colunas com o mesmo número de linhas. Porém, há duas vantagens de se trabalhar com data frames11: (i) Cada coluna pode contar tipos de informações diferentes e (ii) nomeando as colunas podemos acessar colunas específicas sem precisar saber exatamente a indexação da coluna. Essas duas diferenças tornam os data frames o jeito mais comum de se trabalhar com bases de dados no R. Pois podemos ter diversas variáveis, relacionadas a mesma observação, com tipos de informação diferente em uma mesma estrutura! O leitor atento percebeu que a tabela 3.1 é na verdade um exemplo de data frame, onde cada coluna representa uma variável com tipo diferente de informação. Para acessar colunas pelo nome utiliza-se o $ logo em seguida do nome do data frame. Caso quissésemos acessar só os nomes do nosso data frame de empregados poderíamos fazer da seguinte maneira: &gt; empregados$Nome # [1] &quot;Bandar&quot; &quot;Devin&quot; &quot;Nizhoni&quot; # [4] &quot;Henna&quot; &quot;Adrian Christopher&quot; &quot;Jazzmin&quot; # [7] &quot;Noah&quot; &quot;Zong&quot; &quot;James&quot; # [10] &quot;Jesse&quot; O RStudio possui uma ferramenta conveniente para nos ajudar, ao digitar empregados$ e em seguida pressionar TAB o RStudio mostrará um menu dropdown com os nomes das colunas do data frame, como mostra a figura 3.1, de modo que não é necessário sabermos qual o número da coluna em que se encontra a variável de interesse e nem ter que saber de cabeça o nome de todas as variáveis disponíveis no data frame. Figure 3.1: Menu Dropdown do RStudio Outra utilidade do $ quando se tratando de data frames é adicionar novas variáveis ao data frame. Ainda no nosso exemplo do data frame com informações sobre os empregados, poderíamos pensar que foi oferecido aos empregados um treinamento no qual a participação é optativa e depois que o treinamento foi realizado gostaríamos de adicionar uma coluna indicando quais empregados optaram por participar do treinamento. Para facilitar o entendimento vamos supor que os 5 primeiros empregados () optaram por participar do treinamento e os últimos 5 por não participar. Desse modo queremos adicionar uma coluna com o nome de Treinamento que receberá o valor sim caso o empregado tenha participado do treinamento e não caso ele não tenha participado. Isso é feito da seguinte maneira: &gt; empregados$Treinamento &lt;- c(rep(&quot;sim&quot;,5),rep(&quot;não&quot;,5)) A sintaxe c(rep(&quot;sim&quot;,5),rep(&quot;não&quot;,5)) cria um vetor repetindo o termo sim cinco vezes e depois repetindo o termo não também cinco vezes. Agora se verificarmos nosso data frame veremos que a coluna Treinamento adicionada com sucesso. &gt; str(empregados) # &#39;data.frame&#39;: 10 obs. of 7 variables: # $ Nome : chr &quot;Bandar&quot; &quot;Devin&quot; &quot;Nizhoni&quot; &quot;Henna&quot; ... # $ Tempo_emprego: int 1 2 3 4 5 6 7 8 9 10 # $ Setor : Factor w/ 3 levels &quot;Estrutura&quot;,&quot;Financeiro&quot;,..: 2 1 1 3 3 3 1 3 1 1 # $ Peso : num 41.8 40.9 39.6 36.4 44.3 ... # $ Nascimento : Date, format: &quot;1999-09-25&quot; &quot;1999-02-02&quot; ... # $ Casado : logi TRUE TRUE TRUE TRUE FALSE TRUE ... # $ Treinamento : chr &quot;sim&quot; &quot;sim&quot; &quot;sim&quot; &quot;sim&quot; ... Destaco aqui que não mostro como criar data frame do zero, pois como mencionado no início desta seção, os data frames são muito utilizados para armazenar dados que serão importados para dentro do R (colocar aqui o capitulo que falará sobre importar dados para o R) e não digitados no console ou script. 3.5 Listas A última estrutura de dados é chamada de lista (ou vetor recursivo). De maneira objetiva a lista é um vetor no qual seus elementos podem ser qualquer outro tipo de estrutura, isto quer dizer que podemos ter uma lista que contém vetor, matrizes, data frames, listas e etc. Perceba que ao passo que o data frame tem colunas com o mesmo número de linhas as listas tem elementos que não só podem ter número de linhas diferentes como estruturas de dados diferentes! Caso a explicação até agora esteja um pouco abstrata, não se preocupe pois antes de entrarmos na discussão mesmo sobre listas vamos apresentar um exemplo de como as listas são realmente úteis e versáteis quando utilizamos o R. Example 3.1 (Versatilidade da Estrututa Lista) O objetivo desse exemplo é mostrar uma aplicação de como as listas são usadas dentro R, faremos isso mostrando que ao efetuar uma regressão no R os resultados são armazenados em uma lista. Para tal vamos utilizar o dataset gapminder (disponível no pacote gapminder) que é um excerto sobre dados de expectativa de vida, PIB per capita e população por país. Vamos construir um modelo do tipo log-log, para avaliar os efeitos em termos percentuais, onde a expectativa de vida depende do PIB percapita e do tamanho da população. A figura 3.2 traz o resultado da estimação da regressão. Perceba que a regressão, salva com o nome de reg, e o sumário da regressão, salvo como sumario_reg, são listas com 12 e 11 elementos respectivamente. E ao executar o sumário da regressão (linha 4) temos o resultado completo do sumário armazenado na lista. (Obs: não se preocupe em entender o código da figura, mais para frente colocar aqui a seção de sregressão iremos discutir em detalhes como fazer regressão no R). Figure 3.2: Ambiente com objeto regressão Espero que esse exemplo tenha ilustrado como as listas são versáteis e tenha facilitado o entendimento das mesmas, pois tenho certeza que o leitor irá se deparar em diversas situações com listas. Criando listas Para criar uma lista utiliza-se função list() onde os argumentos são os nomes dos elementos e os elementos em si. Uma lista simples pode ser criada da seguinte maneira: &gt; lista &lt;- list(nomes = empregados$Nome, + data_frame = empregados[1:4,-1], + lista = list(numeros=1:10,aleatorio=rnorm(4))) Veja que é possível ter listas como elementos de uma lista (por isso listas são também chamadas de vetores recursivos). Para visualizar a lista no console podemos executar o nome da listano conseole, neste caso lista, nos dando o seguinte resultado: &gt; lista # $nomes # [1] &quot;Bandar&quot; &quot;Devin&quot; &quot;Nizhoni&quot; # [4] &quot;Henna&quot; &quot;Adrian Christopher&quot; &quot;Jazzmin&quot; # [7] &quot;Noah&quot; &quot;Zong&quot; &quot;James&quot; # [10] &quot;Jesse&quot; # # $data_frame # Tempo_emprego Setor Peso Nascimento Casado Treinamento # 1 1 Financeiro 41.75951 1999-09-25 TRUE sim # 2 2 Estrutura 40.87373 1999-02-02 TRUE sim # 3 3 Estrutura 39.58646 1999-06-18 TRUE sim # 4 4 Marketing 36.35106 1999-11-28 TRUE sim # # $lista # $lista$numeros # [1] 1 2 3 4 5 6 7 8 9 10 # # $lista$aleatorio # [1] 2.0197290 2.6354826 0.8802087 -0.5623571 De modo que conseguimos visualizar e entender o que está dentro da nossa lista, porém em casos reais as listas são maiores e com objetos mais complexos e a melhor opção para entender a lista em questão é utilizar a função str(), que nos da o seguinte resultado &gt; str(lista) # List of 3 # $ nomes : chr [1:10] &quot;Bandar&quot; &quot;Devin&quot; &quot;Nizhoni&quot; &quot;Henna&quot; ... # $ data_frame:&#39;data.frame&#39;: 4 obs. of 6 variables: # ..$ Tempo_emprego: int [1:4] 1 2 3 4 # ..$ Setor : Factor w/ 3 levels &quot;Estrutura&quot;,&quot;Financeiro&quot;,..: 2 1 1 3 # ..$ Peso : num [1:4] 41.8 40.9 39.6 36.4 # ..$ Nascimento : Date[1:4], format: &quot;1999-09-25&quot; ... # ..$ Casado : logi [1:4] TRUE TRUE TRUE TRUE # ..$ Treinamento : chr [1:4] &quot;sim&quot; &quot;sim&quot; &quot;sim&quot; &quot;sim&quot; # $ lista :List of 2 # ..$ numeros : int [1:10] 1 2 3 4 5 6 7 8 9 10 # ..$ aleatorio: num [1:4] 2.02 2.635 0.88 -0.562 O output retornado no console da função str() nos mostra que o nosso objeto lista é uma lista de 3 elementos. Onde o primeiro elemento é o vetor nomes, o segundo elemento é um data frame com nome de data_framee o terceiro elemento é uma lista com dois elementos chamada de lista. Acessando elementos das listas De maneira geral há duas maneiras de acessar os elemtos de uma lista: (i) pelo nome dos elementos; e (ii) através da indexação. Para acessar pelo nome basta utilizar o $ como feito com data frames, note que o menu dropdown funciona aqui da mesma forma. A outra maneira de acessar elementos de uma lista á através da indexação, que neste caso devemos ter atenção a um sútil detalhe. De maneira similar as outras estruturas de dados usamos o nome_da_lista[i] para acessar o i-ésimo elemento da lista, mas também podemos acessar o mesmo elemento utilizando [[]], isso mesmo chaves duplas. &gt; x &lt;- lista[1] &gt; y &lt;- lista[[1]] Essa diferença pode parecer inofensiva de início, porém ao observar qual é a estrutura de x e de y nos revela a diferença. &gt; str(x) # List of 1 # $ nomes: chr [1:10] &quot;Bandar&quot; &quot;Devin&quot; &quot;Nizhoni&quot; &quot;Henna&quot; ... &gt; str(y) # chr [1:10] &quot;Bandar&quot; &quot;Devin&quot; &quot;Nizhoni&quot; &quot;Henna&quot; ... Vemos que x é uma lista com o vetor nomes sendo o único elemnto e que y é o vetor nomes. Ou seja, utilizar [] (chaves simples) retorna uma lista ao passo que utilizar [[]] (chaves duplas) retorna a estrutura de dados no elemento que está sendo acessado! 3.6 resumo (melhorar nome) Para sintetizar o que foi apresentado neste capítulo a lista abaixo mostra uma ideia geral de para que são utilizadas na maior parte das vezes cada uma das estruturas de dados no R: vetor = usados salvar uma variável com elementos do mesmo tipo de dado; matriz = usadadas para armazenar mais de uma variável do mesmo tipo de dado; data frame = usados para armazenar mais de uma variável, podendo serem de tipos de dados diferentes (banco de dados); listas = usadas para salvar resultador de estimações valores retornados de função etc. "]
]
